<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DigitalWaveTest</title>

  <!-- React 18.x CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Babel Standalone -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    /* CSS Custom Properties */
    :root {
      --color-primary: #0066cc;
      --color-background: #f5f5f5;
      --color-text: #333333;
      --spacing-unit: 8px;
      --border-radius: 4px;
    }

    /* Global Reset */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    /* Body Styles */
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background-color: var(--color-background);
      color: var(--color-text);
      line-height: 1.6;
      min-width: 1024px;
    }

    /* App Container */
    .app-container {
      padding: calc(var(--spacing-unit) * 4);
      text-align: center;
    }

    .app-container__title {
      color: var(--color-primary);
    }

    /* Error Boundary */
    .error-boundary {
      padding: calc(var(--spacing-unit) * 4);
      text-align: center;
      background-color: #fee;
      border: 1px solid #c00;
      border-radius: var(--border-radius);
      margin: calc(var(--spacing-unit) * 2);
    }

    .error-boundary__title {
      color: #c00;
      margin-bottom: var(--spacing-unit);
    }

    .error-boundary__message {
      color: var(--color-text);
    }

    .error-boundary__button {
      margin-top: calc(var(--spacing-unit) * 2);
      padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
      background-color: var(--color-primary);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
    }

    .error-boundary__button:hover {
      opacity: 0.9;
    }

    /* Chat Interface Component */
    .chat-interface {
      display: flex;
      flex-direction: column;
      height: calc(100vh - calc(var(--spacing-unit) * 8));
      max-width: 900px;
      margin: 0 auto;
      background-color: #ffffff;
      border-radius: var(--border-radius);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    /* Message List Component */
    .chat-interface__message-list {
      flex: 1;
      overflow-y: auto;
      padding: calc(var(--spacing-unit) * 3);
      display: flex;
      flex-direction: column;
      gap: calc(var(--spacing-unit) * 2);
    }

    .chat-interface__empty-state {
      text-align: center;
      color: #999;
      padding: calc(var(--spacing-unit) * 8) calc(var(--spacing-unit) * 4);
      font-size: 16px;
    }

    /* Message Bubble Component */
    .chat-interface__message {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      margin-bottom: calc(var(--spacing-unit) * 2);
    }

    .chat-interface__message--sent {
      align-items: flex-end;
    }

    .chat-interface__message--received {
      align-items: flex-start;
    }

    .chat-interface__message-content {
      max-width: 70%;
      padding: calc(var(--spacing-unit) * 2) calc(var(--spacing-unit) * 3);
      border-radius: calc(var(--spacing-unit) * 2);
      word-wrap: break-word;
      line-height: 1.5;
    }

    .chat-interface__message--sent .chat-interface__message-content {
      background-color: var(--color-primary);
      color: #ffffff;
    }

    .chat-interface__message--received .chat-interface__message-content {
      background-color: #f0f0f0;
      color: var(--color-text);
    }

    /* Input Container */
    .chat-interface__input-container {
      padding: calc(var(--spacing-unit) * 3);
      border-top: 1px solid #e0e0e0;
      background-color: #ffffff;
    }

    /* Chat Input Form */
    .chat-interface__input-form {
      display: flex;
      gap: calc(var(--spacing-unit) * 2);
      align-items: center;
    }

    /* Input Field */
    .chat-interface__input-field {
      flex: 1;
      padding: calc(var(--spacing-unit) * 2) calc(var(--spacing-unit) * 3);
      border: 2px solid #e0e0e0;
      border-radius: var(--border-radius);
      font-size: 16px;
      font-family: inherit;
      outline: none;
      transition: border-color 0.2s ease;
    }

    .chat-interface__input-field:focus {
      border-color: var(--color-primary);
    }

    .chat-interface__input-field:disabled {
      background-color: #f5f5f5;
      cursor: not-allowed;
    }

    /* Button Component */
    .chat-interface__button {
      padding: calc(var(--spacing-unit) * 2) calc(var(--spacing-unit) * 4);
      background-color: var(--color-primary);
      color: #ffffff;
      border: none;
      border-radius: var(--border-radius);
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: opacity 0.2s ease;
      white-space: nowrap;
    }

    .chat-interface__button:hover:not(:disabled) {
      opacity: 0.9;
    }

    .chat-interface__button--disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .chat-interface__button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Validation Error (Story 1.5) */
    .chat-interface__validation-error {
      padding: calc(var(--spacing-unit) * 1) calc(var(--spacing-unit) * 2);
      margin-top: calc(var(--spacing-unit) * 1);
      background-color: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: var(--border-radius);
    }

    .chat-interface__validation-message {
      color: #856404;
      font-size: 14px;
      margin: 0;
    }

    /* Error Display (Story 1.5) */
    .chat-interface__error-display {
      padding: calc(var(--spacing-unit) * 2) calc(var(--spacing-unit) * 3);
      margin-bottom: calc(var(--spacing-unit) * 2);
      background-color: #f8d7da;
      border: 1px solid #f5c6cb;
      border-radius: var(--border-radius);
      display: flex;
      align-items: center;
      gap: calc(var(--spacing-unit) * 2);
    }

    .chat-interface__error-message {
      color: #721c24;
      font-size: 14px;
      margin: 0;
      flex: 1;
    }

    .chat-interface__retry-button {
      padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
      background-color: var(--color-primary);
      color: #ffffff;
      border: none;
      border-radius: var(--border-radius);
      font-size: 14px;
      cursor: pointer;
      white-space: nowrap;
    }

    .chat-interface__retry-button:hover {
      opacity: 0.9;
    }

    /* Story 2.1: "Not Satisfied" button styling */
    .message-bubble__not-satisfied {
      margin-top: calc(var(--spacing-unit) * 1);
      padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 1.5);
      background-color: transparent;
      border: 1px solid var(--color-primary);
      color: var(--color-primary);
      border-radius: var(--border-radius);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.1s ease-in-out;
    }

    .message-bubble__not-satisfied:hover:not(:disabled) {
      background-color: var(--color-primary);
      color: #ffffff;
      opacity: 0.9;
    }

    /* Story 2.2: Feedback Modal Component styling */
    /* Modal Overlay - Semi-transparent backdrop */
    .feedback-modal__overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    /* Modal Container - Centered box */
    .feedback-modal {
      background-color: #ffffff;
      border-radius: calc(var(--border-radius) * 2);
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    }

    /* Modal Header */
    .feedback-modal__header {
      padding: calc(var(--spacing-unit) * 2);
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }

    .feedback-modal__header h2 {
      margin: 0;
      font-size: 24px;
      color: var(--color-text);
      font-weight: 600;
    }

    /* Modal Body */
    .feedback-modal__body {
      padding: calc(var(--spacing-unit) * 2);
    }

    /* Textarea Input */
    .feedback-modal__textarea {
      width: 100%;
      min-height: 100px;
      padding: calc(var(--spacing-unit) * 1);
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: var(--border-radius);
      font-size: 16px;
      font-family: inherit;
      resize: vertical;
      box-sizing: border-box;
    }

    .feedback-modal__textarea:focus {
      outline: 2px solid var(--color-primary);
      border-color: transparent;
    }

    /* Modal Footer */
    .feedback-modal__footer {
      padding: calc(var(--spacing-unit) * 2);
      border-top: 1px solid rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: flex-end;
      gap: calc(var(--spacing-unit) * 1);
    }

    /* Cancel Button - Secondary style */
    .feedback-modal__cancel-button {
      padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 1.5);
      background-color: transparent;
      border: 1px solid var(--color-primary);
      color: var(--color-primary);
      border-radius: var(--border-radius);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.1s ease-in-out;
    }

    .feedback-modal__cancel-button:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    /* Submit Button - Primary style */
    .feedback-modal__submit-button {
      padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 1.5);
      background-color: var(--color-primary);
      border: none;
      color: #ffffff;
      border-radius: var(--border-radius);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.1s ease-in-out;
    }

    .feedback-modal__submit-button:hover:not(:disabled) {
      opacity: 0.9;
    }

    .feedback-modal__submit-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Character Counter */
    .feedback-modal__char-counter {
      margin-top: calc(var(--spacing-unit) * 0.5);
      font-size: 12px;
      color: #666;
      text-align: right;
    }

    .feedback-modal__char-counter--warning {
      color: #f57c00;
    }

    .feedback-modal__char-counter--danger {
      color: #d32f2f;
    }

    /* Story 2.4: Loading Indicator */
    .chat-interface__loading-indicator {
      display: flex;
      align-items: center;
      gap: var(--spacing-unit);
      padding: var(--spacing-unit);
      margin: var(--spacing-unit) 0;
      background-color: rgba(0, 0, 0, 0.02);
      border-radius: var(--border-radius);
      animation: fadeIn 200ms ease-in;
    }

    .chat-interface__loading-spinner {
      width: 16px;
      height: 16px;
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-top-color: var(--color-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .chat-interface__loading-text {
      color: rgba(0, 0, 0, 0.6);
      font-style: italic;
      font-size: 14px;
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }

    /* Not Satisfied button disabled state */
    .message-bubble__not-satisfied:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background-color: rgba(0, 0, 0, 0.1);
    }

    /* Story 4.1: Comparison Modal Component styling */
    /* Modal Overlay - Semi-transparent backdrop */
    .comparison-modal__overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.2s ease-out;
    }

    /* Modal Container - Centered box */
    .comparison-modal {
      background-color: #ffffff;
      border-radius: calc(var(--border-radius) * 2);
      max-width: 900px;
      max-height: 80vh;
      width: 90%;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
      animation: slideUp 0.2s ease-out;
      overflow: hidden;
    }

    /* Modal Header */
    .comparison-modal__header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: calc(var(--spacing-unit) * 1.5);
      border-bottom: 1px solid #e0e0e0;
    }

    .comparison-modal__title {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 0;
      color: var(--color-text);
    }

    .comparison-modal__close-button {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 8px;
      color: #666;
      transition: color 0.2s;
    }

    .comparison-modal__close-button:hover {
      color: #333;
    }

    /* Modal Body - Two Column Layout */
    .comparison-modal__body {
      display: flex;
      gap: calc(var(--spacing-unit) * 2);
      padding: calc(var(--spacing-unit) * 1.5);
      overflow-y: auto;
      flex: 1;
    }

    /* Columns */
    .comparison-modal__column {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0; /* Prevents flex items from overflowing */
    }

    .comparison-modal__column--original {
      /* Left column styling */
    }

    .comparison-modal__column--improved {
      /* Right column styling */
    }

    /* Column Headers */
    .comparison-modal__column-header {
      font-size: 0.875rem;
      font-weight: 600;
      margin-bottom: var(--spacing-unit);
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .comparison-modal__column-header--improved {
      color: var(--color-primary);
    }

    /* Column Content */
    .comparison-modal__content {
      flex: 1;
      font-size: 1rem;
      line-height: 1.6;
      white-space: pre-wrap; /* Preserve line breaks */
      word-wrap: break-word; /* Wrap long words */
      overflow-y: auto; /* Scroll if content is too long */
      padding: calc(var(--spacing-unit) * 2);
    }

    .comparison-modal__prompt-text {
      margin: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    /* Modal Footer */
    .comparison-modal__footer {
      display: flex;
      justify-content: center;
      padding: calc(var(--spacing-unit) * 1.5);
      border-top: 1px solid #e0e0e0;
    }

    /* Story 5.1: Enhanced "Use This Prompt" Button Styling */
    .comparison-modal__use-button {
      padding: 14px 32px;
      font-size: 1rem;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
    }

    .comparison-modal__use-button:hover {
      transform: scale(1.02);
      background: linear-gradient(135deg, #357abd 0%, #2868a8 100%);
      box-shadow: 0 6px 16px rgba(74, 144, 226, 0.4);
    }

    .comparison-modal__use-button:active {
      transform: scale(0.98);
    }

    .comparison-modal__use-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* Story 5.1: Input Highlight Flash Animation */
    .chat-interface__input-field--highlighted {
      animation: inputHighlightFlash 600ms ease-out;
    }

    @keyframes inputHighlightFlash {
      0% {
        background-color: #fff;
      }
      20% {
        background-color: #d4edda; /* Light green flash */
        box-shadow: 0 0 12px rgba(40, 167, 69, 0.5);
      }
      100% {
        background-color: #fff;
        box-shadow: none;
      }
    }

    /* Animations */
    @keyframes slideUp {
      from {
        transform: translateY(20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    /* Scrollbar styling for modal content */
    .comparison-modal__content::-webkit-scrollbar {
      width: 8px;
    }

    .comparison-modal__content::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }

    .comparison-modal__content::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }

    .comparison-modal__content::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    /* Story 4.2: HighlightedText Component Styles */
    .highlighted-text {
      display: inline;
    }

    .highlighted-text__segment {
      display: inline;
      padding: 1px 3px;
      border-radius: 3px;
      transition: background-color 0.2s ease, transform 0.1s ease;
      line-height: 1.4;
      box-decoration-break: clone;
      -webkit-box-decoration-break: clone;
    }

    /* Addition highlight - Green/yellow background (subtle) */
    .highlighted-text__segment--addition {
      background-color: #d4edda; /* Subtle green */
      color: #155724;
    }

    .highlighted-text__segment--addition:hover {
      background-color: #c3e6cb; /* Slightly darker on hover */
      transform: scale(1.02);
    }

    /* Change highlight - Orange/amber background */
    .highlighted-text__segment--change {
      background-color: #fff3cd; /* Subtle orange/amber */
      color: #856404;
    }

    .highlighted-text__segment--change:hover {
      background-color: #ffeeba;
      transform: scale(1.02);
    }

    /* Enhancement highlight - Blue/purple background */
    .highlighted-text__segment--enhancement {
      background-color: #d1ecf1; /* Subtle blue */
      color: #0c5460;
    }

    .highlighted-text__segment--enhancement:hover {
      background-color: #bee5eb;
      transform: scale(1.02);
    }

    /* Story 4.3: ImprovedPromptWithBadges Styles */
    .improved-prompt-with-badges {
      display: inline;
    }

    /* Story 4.4: Tooltip Component Styles */
    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip__content {
      position: fixed; /* Fixed positioning to avoid clipping by modal overflow */
      top: 50%; /* Center vertically - will be positioned by JS */
      left: 50%; /* Center horizontally - will be positioned by JS */
      transform: translate(-50%, -50%); /* Center on viewport */
      max-width: 500px; /* Much wider for better readability */
      min-width: 300px; /* Minimum width for consistent appearance */
      padding: 16px 20px; /* More padding for better readability */
      background-color: rgba(44, 62, 80, 0.85); /* Dark background with 85% opacity */
      color: #f8f9fa; /* High contrast text */
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3); /* Stronger shadow for floating effect */
      font-size: 0.9375rem; /* Slightly larger font (15px) */
      line-height: 1.6; /* Better line spacing */
      text-align: left; /* Left align for better readability */
      white-space: pre-wrap; /* Preserve newlines and wrap text */
      word-wrap: break-word; /* Break long words */
      z-index: 9999; /* Very high z-index to be above everything including modal */
      opacity: 0;
      animation: tooltipFadeIn 0.2s ease-out forwards;
      backdrop-filter: blur(10px); /* Blur background behind tooltip */
      -webkit-backdrop-filter: blur(10px); /* Safari support */
    }

    .tooltip__arrow {
      display: none; /* Hide arrow for centered modal-style tooltip */
    }

    @keyframes tooltipFadeIn {
      from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* Focus indicator for keyboard accessibility */
    .tooltip > span[tabindex="0"]:focus {
      outline: 2px solid #4a90e2;
      outline-offset: 2px;
      border-radius: 3px;
    }

    /* Story 5.3: Session Management - Reset Button and Modal Styles */
    /* Chat Interface Header */
    .chat-interface__header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #e5e7eb;
      background-color: #f9fafb;
    }

    .chat-interface__title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #111827;
      margin: 0;
    }

    /* Reset Button - Secondary Style */
    .chat-interface__reset-button {
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      font-weight: 500;
      color: #6b7280;
      background-color: transparent;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .chat-interface__reset-button:hover {
      color: #374151;
      background-color: #f3f4f6;
      border-color: #9ca3af;
      transform: scale(1.02);
    }

    .chat-interface__reset-button:active {
      transform: scale(0.98);
    }

    .chat-interface__reset-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .chat-interface__reset-button:focus {
      outline: 2px solid #4a90e2;
      outline-offset: 2px;
    }

    /* Reset Confirmation Modal */
    .reset-modal__overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.2s ease-out;
    }

    .reset-modal {
      background-color: #fff;
      border-radius: 12px;
      padding: 2rem;
      max-width: 450px;
      width: 90%;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
      animation: slideUp 0.2s ease-out;
    }

    .reset-modal__header {
      margin-bottom: 1rem;
    }

    .reset-modal__title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #111827;
      margin: 0;
    }

    .reset-modal__body {
      margin-bottom: 1.5rem;
    }

    .reset-modal__message {
      font-size: 1rem;
      color: #6b7280;
      margin: 0;
      line-height: 1.5;
    }

    .reset-modal__footer {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
    }

    .reset-modal__button {
      padding: 0.625rem 1.25rem;
      font-size: 0.875rem;
      font-weight: 500;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .reset-modal__button--cancel {
      color: #374151;
      background-color: #fff;
      border: 1px solid #d1d5db;
    }

    .reset-modal__button--cancel:hover {
      background-color: #f9fafb;
      border-color: #9ca3af;
    }

    .reset-modal__button--confirm {
      color: #fff;
      background-color: #ef4444;
      border: 1px solid #ef4444;
    }

    .reset-modal__button--confirm:hover {
      background-color: #dc2626;
      border-color: #dc2626;
    }

    .reset-modal__button:focus {
      outline: 2px solid #4a90e2;
      outline-offset: 2px;
    }

    /* Empty state message enhancement */
    .message-list__empty-state {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      min-height: 300px;
    }

    .message-list__empty-text {
      font-size: 1rem;
      color: #9ca3af;
      text-align: center;
    }

    /* Story 5.4: Error Message Container */
    .error-message {
      padding: 0.75rem 1rem;
      margin-bottom: 1rem;
      background-color: #fef2f2;
      border: 1px solid #fecaca;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      align-items: flex-start;
    }

    .error-message__text {
      margin: 0;
      font-size: 0.875rem;
      color: #991b1b;
      line-height: 1.5;
    }

    /* Story 5.4: Retry Button */
    .retry-button {
      align-self: flex-start;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      font-weight: 500;
      color: #fff;
      background-color: #dc2626;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .retry-button:hover {
      background-color: #b91c1c;
      transform: scale(1.02);
    }

    .retry-button:active {
      transform: scale(0.98);
    }

    .retry-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .retry-button:focus {
      outline: 2px solid #dc2626;
      outline-offset: 2px;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    // ============================================================
    // SECTION 1: CONSTANTS & CONFIGURATION
    // ============================================================

    // API Configuration
    const WORKER_URL = 'https://digitalwave-test-proxy.x-gs-x.workers.dev';
    const CHAT_SYSTEM_PROMPT = 
      `You are a helpful assistant. Respond to user prompts naturally.

      You can ONLY assist with product name generation based on the packaging options below. 
      If the user asks about anything else, politely decline and redirect them to select a 
      packaging option for name generation.

      ## Task
      You are testing a product name generation system. The user will select one of four 
      product packaging options below. Based on the packaging description, generate an 
      appropriate product name.

      ## Available Product Packaging Options

      **Option 1 - Condiment Packet:**
      A single-serve foil condiment packet containing ketchup. The packaging features a 
      patriotic red, white, and blue color scheme with a triangular flag-inspired graphic 
      containing stars. The design includes a charitable cause partnership badge and 
      ingredient information printed on the side. The overall aesthetic suggests 
      American-made, family-values branding.

      **Option 2 - Dairy Carton:**
      A gable-top cardboard milk carton with a blue plastic screw cap. The design uses a 
      blue and white color palette with stylized milk splash graphics. Features include a 
      "Natural" diagonal ribbon banner, a circular quality seal badge, and fresh dairy 
      imagery. The typography is clean and modern with rounded lettering.

      **Option 3 - Beverage Cans (Variety Pack):**
      A set of three aluminum soda cans marketed as a healthier alternative. Features 
      retro-style curved script typography as the main logo. Flavors shown: a dark red 
      cola-style variant, a pink cherry cola, and an orange root beer with a float 
      illustration. Each can displays health claims including prebiotics, vitamins, 
      minerals, low sugar content (5-6g), and NON-GMO certification.

      **Option 4 - Cheese Product:**
      Processed cheese slices in a blue plastic and cardboard package. Contains 12
      individually wrapped slices, 200g total weight. The packaging shows a burger
      photograph demonstrating product usage. Multilingual text appears in Arabic, English,
      and Spanish. The brand logo uses a simple, friendly rounded typeface in a dark blue
      oval.`;

    const IMPROVEMENT_SYSTEM_PROMPT = `You are a prompt engineering expert. Analyze the user's original prompt and restructure it using the Rules/Task/Examples framework.

Rules: Constraints and guidelines the AI should follow
Task: Clear, specific instruction of what to generate
Examples: Sample outputs showing desired style

Return JSON with:
- improvedPrompt: restructured version
- mapping: [{originalSentence, improvedSections: []}]
- explanations: [{section, tooltip}]`;

    const CHAT_TIMEOUT = 10000; // 10 seconds for chat API
    const IMPROVEMENT_TIMEOUT = 15000; // 15 seconds for improvement generation (NFR-P4)
    const MAX_PROMPT_LENGTH = 2000;

    // ============================================================
    // SECTION 2: UTILITY FUNCTIONS
    // ============================================================

    // parseImprovedPrompt - Parse improved prompt to extract R/T/E section highlights (Story 4.2)
    // Returns array of highlight objects for HighlightedText component
    // Each highlight object: { text, type, startIndex, endIndex }
    // Type can be: 'addition' (section headers), 'enhancement' (section content)
    // Story 4.2 Performance: Measures parsing time to verify <200ms target (NFR-P6)
    const parseImprovedPrompt = (improvedPrompt) => {
      const startTime = performance.now();

      if (!improvedPrompt || typeof improvedPrompt !== 'string') {
        return [];
      }

      const highlights = [];
      const sections = [
        { name: 'Rules', pattern: /Rules:/i },
        { name: 'Task', pattern: /Task:/i },
        { name: 'Examples', pattern: /Examples:/i }
      ];

      sections.forEach(section => {
        const match = improvedPrompt.match(section.pattern);
        if (match) {
          const startIndex = match.index;
          const endIndex = startIndex + match[0].length;

          // Highlight section header (e.g., "Rules:")
          highlights.push({
            text: match[0],
            type: 'addition',
            startIndex: startIndex,
            endIndex: endIndex
          });

          // Find the end of this section (start of next section or end of string)
          let sectionEnd = improvedPrompt.length;
          for (let nextSection of sections) {
            if (nextSection.name !== section.name) {
              const nextMatch = improvedPrompt.match(nextSection.pattern);
              if (nextMatch && nextMatch.index > endIndex) {
                sectionEnd = nextMatch.index;
                break;
              }
            }
          }

          // Highlight section content (after header until next section)
          if (sectionEnd > endIndex) {
            // Find the actual end of content (skip trailing whitespace) for highlighting
            const contentEnd = improvedPrompt.substring(endIndex, sectionEnd).trimEnd().length + endIndex;

            // Keep original text for display (includes newlines between sections)
            highlights.push({
              text: improvedPrompt.substring(endIndex, sectionEnd),
              type: 'enhancement',
              startIndex: endIndex,
              endIndex: contentEnd
            });
          }
        }
      });

      const endTime = performance.now();
      const parsingTime = endTime - startTime;

      // Log performance in development (verify <200ms target per NFR-P6)
      if (parsingTime > 50) {
        console.warn(`parseImprovedPrompt took ${parsingTime.toFixed(2)}ms (target: <200ms)`);
      }

      return highlights;
    };

    // Error formatting utility - maps technical errors to user-friendly messages
    // Returns error object: { message, code, details }
    // Enhanced for Story 5.4: Comprehensive error handling
    function formatError(error) {
      // Extract error code and message from various error types
      let errorCode = 'UNKNOWN';
      let errorMessage = 'Something went wrong. Please try again.';
      let errorDetails = '';

      if (error && typeof error === 'object') {
        // Handle Error objects with code property
        if (error.code) {
          errorCode = error.code;
          errorMessage = error.message || errorMessage;
          errorDetails = error.details || '';
        }
        // Handle fetch Response errors
        else if (error.status) {
          errorCode = getStatusErrorCode(error.status);
          errorMessage = getErrorMessageForStatus(error.status);
          errorDetails = error.statusText || '';
        }
        // Handle standard Error objects
        else if (error.message) {
          // Check for TypeError from fetch (likely CORS or worker unavailable)
          if (error.name === 'TypeError' && (error.message.includes('fetch') || error.message.includes('Failed to fetch'))) {
            errorCode = 'WORKER_UNAVAILABLE';
            errorMessage = 'Service temporarily unavailable. Please try again.';
          }
          // Parse error message for known patterns
          else if (error.message.includes('timeout') || error.message.includes('Timeout')) {
            errorCode = 'API_TIMEOUT';
            errorMessage = 'The request took too long. Please try again.';
          } else if (error.message.includes('network') || error.message.includes('Network')) {
            errorCode = 'NETWORK_ERROR';
            errorMessage = 'Connection issue. Please check your internet and try again.';
          } else if (error.message.includes('rate limit') || error.message.includes('429')) {
            errorCode = 'RATE_LIMIT_EXCEEDED';
            errorMessage = 'We\'re experiencing high demand. Please wait a moment and try again.';
          }
          errorDetails = error.message;
        }
      } else if (typeof error === 'string') {
        // Handle string errors (legacy, shouldn't happen)
        errorMessage = error;
        errorDetails = error;
      }

      // Error code to message mapping
      const errorMessages = {
        'API_TIMEOUT': 'The request took too long. Please try again.',
        'RATE_LIMIT_EXCEEDED': 'We\'re experiencing high demand. Please wait a moment and try again.',
        'AUTHENTICATION_FAILED': 'Service configuration error. Please contact support.',
        'NETWORK_ERROR': 'Connection issue. Please check your internet and try again.',
        'WORKER_UNAVAILABLE': 'Service temporarily unavailable. Please try again.',
        'INVALID_RESPONSE': 'The AI returned an invalid response. Please try again.',
        'MISSING_FIELDS': 'Required information is missing. Please check your input and try again.',
        'UNKNOWN': 'Something went wrong. Please try again.'
      };

      // Get user-friendly message for error code
      const userMessage = errorMessages[errorCode] || errorMessages.UNKNOWN;

      return {
        code: errorCode,
        message: userMessage,
        details: errorDetails
      };
    }

    // Helper: Map HTTP status to error code
    function getStatusErrorCode(status) {
      const statusMap = {
        401: 'AUTHENTICATION_FAILED',
        429: 'RATE_LIMIT_EXCEEDED',
        500: 'WORKER_UNAVAILABLE',
        502: 'WORKER_UNAVAILABLE',
        503: 'WORKER_UNAVAILABLE',
        504: 'API_TIMEOUT'
      };
      return statusMap[status] || 'UNKNOWN';
    }

    // Helper: Get message for HTTP status
    function getErrorMessageForStatus(status) {
      const messages = {
        401: 'Service configuration error. Please contact support.',
        429: 'We\'re experiencing high demand. Please wait a moment and try again.',
        500: 'Service temporarily unavailable. Please try again.',
        502: 'Service temporarily unavailable. Please try again.',
        503: 'Service temporarily unavailable. Please try again.',
        504: 'The request took too long. Please try again.'
      };
      return messages[status] || 'Something went wrong. Please try again.';
    }

    // Chat API integration - calls Cloudflare Worker proxy
    // Returns: Promise with AI response message
    // Throws: Formatted error object with code and message
    async function callChatAPI(userPrompt) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), CHAT_TIMEOUT);

        const response = await fetch(`${WORKER_URL}/api/chat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt: userPrompt }),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();

        if (!result.success) {
          throw new Error(result.error?.message || 'API call failed');
        }

        return result.data.message;
      } catch (error) {
        if (error.name === 'AbortError') {
          throw formatError({ code: 'API_TIMEOUT' });
        }
        throw formatError(error);
      }
    }

    // Improvement API integration - calls Cloudflare Worker proxy for prompt enhancement
    // Returns: Promise with { improvedPrompt, mapping, explanations }
    // Throws: Formatted error object with code and message
    async function generateImprovement(originalPrompt, userFeedback) {
      // Validate inputs
      if (!originalPrompt || typeof originalPrompt !== 'string' || originalPrompt.trim() === '') {
        throw formatError({ code: 'MISSING_FIELDS', message: 'Original prompt is required' });
      }

      if (!userFeedback || typeof userFeedback !== 'string' || userFeedback.trim() === '') {
        throw formatError({ code: 'MISSING_FIELDS', message: 'User feedback is required' });
      }

      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), IMPROVEMENT_TIMEOUT);

        const response = await fetch(`${WORKER_URL}/api/improve`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            originalPrompt: originalPrompt.trim(),
            userFeedback: userFeedback.trim()
          }),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();

        if (!result.success) {
          throw new Error(result.error?.message || 'Unknown error');
        }

        // Parse and validate response using parseImprovementResponse utility
        const improvementData = parseImprovementResponse(result);

        return improvementData;

      } catch (error) {
        // Format error for user-friendly display
        if (error.name === 'AbortError') {
          throw formatError({ code: 'API_TIMEOUT', message: 'Request timeout' });
        }

        if (error.message.includes('fetch') || error.message.includes('Network')) {
          throw formatError({ code: 'NETWORK_ERROR', message: error.message });
        }

        // Handle parseImprovementResponse errors
        if (error.message && error.message.includes('INVALID_RESPONSE')) {
          throw formatError({ code: 'INVALID_RESPONSE', message: error.message });
        }

        // Re-throw formatted errors
        throw error;
      }
    }

    // Response parsing utility - validates and parses improvement API response
    // Returns: { improvedPrompt, mapping, explanations }
    // Throws: Error with code 'INVALID_RESPONSE' if validation fails
    function parseImprovementResponse(apiResponse) {
      // Extract data from Worker response
      const { success, data, error } = apiResponse;

      // Check for Worker error
      if (!success || error) {
        throw new Error(error?.code || 'WORKER_UNAVAILABLE');
      }

      // Validate improvedPrompt
      if (!data.improvedPrompt || typeof data.improvedPrompt !== 'string') {
        throw new Error('INVALID_RESPONSE: Missing or invalid improvedPrompt');
      }

      if (data.improvedPrompt.trim().length === 0) {
        throw new Error('INVALID_RESPONSE: improvedPrompt is empty');
      }

      // Validate mapping
      if (!data.mapping || !Array.isArray(data.mapping)) {
        throw new Error('INVALID_RESPONSE: Missing or invalid mapping');
      }

      if (data.mapping.length === 0) {
        throw new Error('INVALID_RESPONSE: mapping array is empty');
      }

      // Validate each mapping item
      for (let i = 0; i < data.mapping.length; i++) {
        const item = data.mapping[i];

        if (!item.originalSentence || typeof item.originalSentence !== 'string') {
          throw new Error(`INVALID_RESPONSE: mapping[${i}] missing originalSentence`);
        }

        if (!item.improvedSections || !Array.isArray(item.improvedSections)) {
          throw new Error(`INVALID_RESPONSE: mapping[${i}] missing improvedSections`);
        }

        if (item.improvedSections.length === 0) {
          throw new Error(`INVALID_RESPONSE: mapping[${i}].improvedSections is empty`);
        }
      }

      // Validate explanations
      if (!data.explanations || !Array.isArray(data.explanations)) {
        throw new Error('INVALID_RESPONSE: Missing or invalid explanations');
      }

      if (data.explanations.length !== 3) {
        throw new Error('INVALID_RESPONSE: Expected exactly 3 explanations (Rules, Task, Examples)');
      }

      // Validate each explanation
      const requiredSections = ['Rules', 'Task', 'Examples'];
      const foundSections = [];

      for (let i = 0; i < data.explanations.length; i++) {
        const explanation = data.explanations[i];

        if (!explanation.section || typeof explanation.section !== 'string') {
          throw new Error(`INVALID_RESPONSE: explanations[${i}] missing section`);
        }

        if (!explanation.tooltip || typeof explanation.tooltip !== 'string') {
          throw new Error(`INVALID_RESPONSE: explanations[${i}] missing tooltip`);
        }

        if (explanation.tooltip.trim().length === 0) {
          throw new Error(`INVALID_RESPONSE: explanations[${i}].tooltip is empty`);
        }

        foundSections.push(explanation.section);
      }

      // Verify all required sections are present
      for (const required of requiredSections) {
        if (!foundSections.includes(required)) {
          throw new Error(`INVALID_RESPONSE: Missing explanation for ${required} section`);
        }
      }

      // Return validated data
      return {
        improvedPrompt: data.improvedPrompt,
        mapping: data.mapping,
        explanations: data.explanations
      };
    }

    // ============================================================
    // SECTION 3: CUSTOM HOOKS
    // ============================================================

    // AC #7: useAppContext custom hook with null safety check
    // Note: This hook references AppContext defined in SECTION 5.
    // This works due to JavaScript hoisting and is intentional pattern for hooks.
    const useAppContext = () => {
      const context = React.useContext(AppContext);
      if (context === null) {
        throw new Error('useAppContext must be used within an AppProvider');
      }
      return context;
    };

    // ============================================================
    // SECTION 4: REACT COMPONENTS
    // ============================================================

    // ErrorBoundary - Class component for catching React errors (must be first)
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
      }

      static getDerivedStateFromError(error) {
        return { hasError: true, error };
      }

      componentDidCatch(error, errorInfo) {
        console.error('ErrorBoundary caught an error:', error, errorInfo);
      }

      handleRetry = () => {
        this.setState({ hasError: false, error: null });
      };

      render() {
        if (this.state.hasError) {
          return (
            <div className="error-boundary">
              <h2 className="error-boundary__title">Something went wrong</h2>
              <p className="error-boundary__message">
                The application encountered an unexpected error.
              </p>
              <button className="error-boundary__button" onClick={this.handleRetry}>
                Try Again
              </button>
            </div>
          );
        }

        return this.props.children;
      }
    }

    // LEAF COMPONENTS (defined first)

    // Tooltip - Leaf component for displaying contextual help on hover/focus (Story 4.4)
    // Provides educational explanations for R/T/E framework sections
    // Props: children (React element) - Element that triggers the tooltip
    //        content (string or React node) - Tooltip content text
    // Accessibility: Keyboard accessible (focus/blur), screen reader support (aria-describedby), ESC key dismiss
    const Tooltip = ({ children, content }) => {
      const [isVisible, setIsVisible] = React.useState(false);
      const [timeoutId, setTimeoutId] = React.useState(null);
      const tooltipRef = React.useRef(null);

      // Show tooltip with small delay to prevent accidental triggers
      const handleMouseEnter = React.useCallback(() => {
        const id = setTimeout(() => {
          setIsVisible(true);
        }, 100); // 100ms delay
        setTimeoutId(id);
      }, []);

      // Hide tooltip immediately on mouse leave
      const handleMouseLeave = React.useCallback(() => {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        setIsVisible(false);
      }, [timeoutId]);

      // Handle keyboard accessibility
      const handleFocus = React.useCallback(() => {
        setIsVisible(true);
      }, []);

      const handleBlur = React.useCallback(() => {
        setIsVisible(false);
      }, []);

      // Handle ESC key to dismiss
      React.useEffect(() => {
        const handleEscape = (e) => {
          if (e.key === 'Escape' && isVisible) {
            setIsVisible(false);
          }
        };

        document.addEventListener('keydown', handleEscape);
        return () => {
          document.removeEventListener('keydown', handleEscape);
        };
      }, [isVisible]);

      // Clear timeout on unmount
      React.useEffect(() => {
        return () => {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
        };
      }, [timeoutId]);

      // Generate unique ID for aria-describedby
      const tooltipId = React.useId();
      const contentId = `tooltip-content-${tooltipId}`;

      return (
        <span
          className="tooltip"
          onMouseEnter={handleMouseEnter}
          onMouseLeave={handleMouseLeave}
          ref={tooltipRef}
        >
          <span
            onFocus={handleFocus}
            onBlur={handleBlur}
            tabIndex={0}
            aria-describedby={isVisible ? contentId : undefined}
          >
            {children}
          </span>

          {isVisible && (
            <div
              id={contentId}
              className="tooltip__content"
              role="tooltip"
              aria-live="polite"
            >
              <div className="tooltip__arrow"></div>
              {content}
            </div>
          )}
        </span>
      );
    };

    // HighlightedText - Leaf component for rendering text with highlighted segments (Story 4.2)
    // Used to display improved prompt with color-coded R/T/E sections
    // Props: text (string) - The full text to render
    //        highlights (array) - Array of highlight objects: [{ text, type, startIndex, endIndex }]
    //        type: 'addition' | 'change' | 'enhancement'
    // Story 4.2 Performance: Measures rendering time to verify <200ms target (NFR-P6)
    const HighlightedText = ({ text, highlights }) => {
      const renderStartTime = React.useRef(null);

      // Measure render performance (using useEffect to capture after render)
      React.useEffect(() => {
        if (renderStartTime.current) {
          const renderEndTime = performance.now();
          const renderTime = renderEndTime - renderStartTime.current;

          // Log performance in development (verify <200ms target per NFR-P6)
          if (renderTime > 100) {
            console.warn(`HighlightedText render took ${renderTime.toFixed(2)}ms (target: <200ms)`);
          }
        }
      });

      // Start render timer
      renderStartTime.current = performance.now();

      // Guard clause - handle empty highlights gracefully
      if (!text || !highlights || highlights.length === 0) {
        return <span>{text}</span>;
      }

      // Sort highlights by startIndex to ensure correct order
      const sortedHighlights = [...highlights].sort((a, b) => a.startIndex - b.startIndex);

      // Build array of text segments (highlighted and non-highlighted)
      const segments = [];
      let lastIndex = 0;

      sortedHighlights.forEach(highlight => {
        // Add non-highlighted text before this highlight
        if (highlight.startIndex > lastIndex) {
          segments.push({
            text: text.substring(lastIndex, highlight.startIndex),
            type: null
          });
        }

        // Add highlighted segment
        segments.push({
          text: text.substring(highlight.startIndex, highlight.endIndex),
          type: highlight.type
        });

        lastIndex = highlight.endIndex;
      });

      // Add remaining text after last highlight
      if (lastIndex < text.length) {
        segments.push({
          text: text.substring(lastIndex),
          type: null
        });
      }

      return (
        <span className="highlighted-text">
          {segments.map((segment, index) => {
            if (segment.type) {
              return (
                <span
                  key={index}
                  className={`highlighted-text__segment highlighted-text__segment--${segment.type}`}
                >
                  {segment.text}
                </span>
              );
            }
            return <span key={index}>{segment.text}</span>;
          })}
        </span>
      );
    };

    // Button - Reusable button component with disabled state
    // AC #1: Button component with children, onClick, disabled, className props
    const Button = ({ children, onClick, disabled = false, className = '' }) => {
      const baseClass = 'chat-interface__button';
      const modifierClass = disabled ? 'chat-interface__button--disabled' : '';
      const combinedClassName = `${baseClass} ${modifierClass} ${className}`.trim().replace(/\s+/g, ' ');

      return (
        <button
          className={combinedClassName}
          onClick={onClick}
          disabled={disabled}
        >
          {children}
        </button>
      );
    };

    // LoadingIndicator - Display loading state with spinner (Story 2.4)
    // Leaf component for showing feedback processing state
    // Props: message (string) - Display text for loading indicator
    const LoadingIndicator = ({ message = "Generating improvement..." }) => {
      return (
        <div className="chat-interface__loading-indicator">
          <div className="chat-interface__loading-spinner"></div>
          <span className="chat-interface__loading-text">{message}</span>
        </div>
      );
    };

    // ValidationError - Display validation error messages (Story 1.5)
    // Leaf component for inline validation feedback
    // Memoized to prevent unnecessary re-renders
    const ValidationError = React.memo(({ error }) => {
      if (!error) return null;

      return (
        <div className="chat-interface__validation-error">
          <p className="chat-interface__validation-message">{error.message}</p>
        </div>
      );
    });

    // ErrorDisplay - Display API error messages with retry button (Story 1.5)
    // Leaf component for API error feedback
    // Memoized to prevent unnecessary re-renders
    const ErrorDisplay = React.memo(({ error, onRetry }) => {
      if (!error) return null;

      const isRetriable = ['API_TIMEOUT', 'NETWORK_ERROR', 'RATE_LIMIT_EXCEEDED'].includes(error.code);

      return (
        <div className="chat-interface__error-display">
          <p className="chat-interface__error-message">{error.message}</p>
          {isRetriable && onRetry && (
            <Button onClick={onRetry} className="chat-interface__retry-button">
              Try Again
            </Button>
          )}
        </div>
      );
    });

    // MessageBubble - Display individual chat message with role-based styling
    // AC #2: MessageBubble component with message object and type prop
    // Story 2.1: Added showNotSatisfiedButton, onNotSatisfied, disabled props for "Not Satisfied" button
    // Story 2.4: Button disabled when isGeneratingImprovement is true
    const MessageBubble = ({ message, type, showNotSatisfiedButton, onNotSatisfied, disabled }) => {
      const typeClass = type === 'sent' ? 'chat-interface__message--sent' : 'chat-interface__message--received';
      const isAI = message.role === 'assistant';

      return (
        <div className={`chat-interface__message ${typeClass}`}>
          <div className="chat-interface__message-content">
            {message.content}
          </div>
          {/* Story 2.1: Conditionally render "Not Satisfied" button on AI messages (outside content div for proper spacing) */}
          {/* Story 2.4: Button disabled during improvement generation */}
          {showNotSatisfiedButton && isAI && (
            <button
              className="message-bubble__not-satisfied"
              onClick={onNotSatisfied}
              disabled={disabled}
            >
              Not Satisfied
            </button>
          )}
        </div>
      );
    };

    // COMPOSITE COMPONENTS (defined after leaf components)

    // ImprovedPromptWithBadges - Renders improved prompt with highlights and educational tooltips (Story 4.2, 4.4)
    // Story 4.4: Adds educational tooltips on the improved prompt explaining the R/T/E framework
    // Props: text (string) - Improved prompt text, highlights (array) - From parseImprovedPrompt()
    //        explanations (array) - Section explanations from comparisonData.explanations (Story 4.4)
    const ImprovedPromptWithBadges = ({ text, highlights, explanations }) => {

      // Story 4.4: Helper function to get educational tooltip content for a section
      // Now used for tooltip on the entire improved prompt
      const getTooltipContent = React.useCallback(() => {
        if (!explanations || explanations.length === 0) {
          // Fallback to generic framework education tooltip
          return "This improved prompt follows the R/T/E framework: Rules establish constraints, Task defines what to generate, and Examples provide reference points for better AI responses.";
        }

        // Combine all explanations for comprehensive tooltip
        return explanations.map(ex => ex.tooltip || `This ${ex.section.toLowerCase()} section helps structure your prompt.`).join(' ');
      }, [explanations]);

      // Parse highlights and create segments
      const segmentsWithBadges = React.useMemo(() => {
        if (!highlights || highlights.length === 0) {
          return [{ text, type: null }];
        }

        const segments = [];
        let lastIndex = 0;

        highlights.forEach(highlight => {
          // Add non-highlighted text before this highlight
          if (highlight.startIndex > lastIndex) {
            segments.push({
              text: text.substring(lastIndex, highlight.startIndex),
              type: null
            });
          }

          // Add highlighted segment
          segments.push({
            text: text.substring(highlight.startIndex, highlight.endIndex),
            type: highlight.type
          });

          lastIndex = highlight.endIndex;
        });

        // Add remaining text after last highlight
        if (lastIndex < text.length) {
          segments.push({
            text: text.substring(lastIndex),
            type: null
          });
        }

        return segments;
      }, [text, highlights]);

      return (
        <Tooltip content={getTooltipContent()}>
          <span className="improved-prompt-with-badges">
            {segmentsWithBadges.map((segment, index) => {
              if (segment.type) {
                return (
                  <span
                    key={index}
                    className={`highlighted-text__segment highlighted-text__segment--${segment.type}`}
                  >
                    {segment.text}
                  </span>
                );
              }
              return <span key={index}>{segment.text}</span>;
            })}
          </span>
        </Tooltip>
      );
    };

    // MessageList - Display list of chat messages with auto-scroll
    // AC #3: MessageList component with auto-scroll and empty state
    // Story 2.1: Added mostRecentAIMessage, onNotSatisfied, isFeedbackModalOpen props for "Not Satisfied" button
    // Story 2.4: Added isGeneratingImprovement to disable button during loading
    const MessageList = ({ messages, mostRecentAIMessage, onNotSatisfied, isFeedbackModalOpen, isGeneratingImprovement }) => {
      const messagesEndRef = React.useRef(null);

      // Auto-scroll to bottom when messages change
      React.useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages]);

      if (messages.length === 0) {
        return (
          <div className="chat-interface__message-list">
            <div className="message-list__empty-state">
              <p className="message-list__empty-text" role="status">
                No messages yet. Start by entering a prompt.
              </p>
            </div>
          </div>
        );
      }

      return (
        <div className="chat-interface__message-list">
          {messages.map((message, index) => {
            const isMostRecentAI = mostRecentAIMessage && message === mostRecentAIMessage;
            const isDisabled = isFeedbackModalOpen || isGeneratingImprovement;

            return (
              <MessageBubble
                key={index}
                message={message}
                type={message.role === 'user' ? 'sent' : 'received'}
                showNotSatisfiedButton={isMostRecentAI}
                onNotSatisfied={onNotSatisfied}
                disabled={isDisabled}
              />
            );
          })}
          <div ref={messagesEndRef} />
        </div>
      );
    };

    // RetryButton - Leaf component for error display with retry functionality
    // Story 5.4: Retry mechanism for failed API calls
    // Props: onRetry (function), error (object with { message, code }), isRetrying (boolean)
    const RetryButton = ({ onRetry, error, isRetrying }) => {
      // Don't render if no error
      if (!error) return null;

      // Check if error is retryable
      const retryableErrorCodes = ['API_TIMEOUT', 'NETWORK_ERROR', 'RATE_LIMIT_EXCEEDED'];
      const isRetryable = retryableErrorCodes.includes(error.code);

      const handleRetry = () => {
        if (onRetry && typeof onRetry === 'function' && !isRetrying) {
          onRetry();
        }
      };

      return (
        React.createElement('div', { className: 'error-message', role: 'alert', 'aria-live': 'polite' },
          React.createElement('p', { className: 'error-message__text' }, error.message),
          isRetryable && React.createElement('button', {
            className: 'retry-button',
            onClick: handleRetry,
            disabled: isRetrying,
            type: 'button'
          }, isRetrying ? 'Retrying...' : 'Try Again')
        )
      );
    };

    // ChatInput - Input field with send button
    // AC #4: ChatInput component with onSubmit and isLoading props
    // Story 2.4: Added optional disable during improvement generation
    // Story 5.4: Added error, onRetry, and isRetrying props for error display with retry
    const ChatInput = React.forwardRef(({ onSubmit, isLoading = false, value, onChange, isHighlighted = false, error, onRetry, isRetrying }, ref) => {
      const { validationError, setValidationError, isGeneratingImprovement } = useAppContext();
      const inputRef = React.useRef(null);

      // Story 5.1: Expose focus method via useImperativeHandle
      React.useImperativeHandle(ref, () => ({
        focus: () => {
          if (inputRef.current) {
            inputRef.current.focus();
            // Move cursor to end of text
            inputRef.current.setSelectionRange(value.length, value.length);
          }
        }
      }), [value]);

      // Optimize handleChange with useCallback to prevent unnecessary re-renders
      const handleChange = React.useCallback((e) => {
        onChange(e.target.value);
        // Clear validation error when user starts typing
        if (validationError && e.target.value.trim()) {
          setValidationError(null);
        }
      }, [validationError, setValidationError, onChange]);

      // Optimize handleSubmit with useCallback
      const handleSubmit = React.useCallback((e) => {
        e.preventDefault();

        // Validation: Empty input
        if (!value.trim()) {
          setValidationError({ message: 'Please enter a prompt', code: 'EMPTY_INPUT' });
          inputRef.current?.focus();
          return;
        }

        // Validation: Maximum length
        if (value.length > MAX_PROMPT_LENGTH) {
          setValidationError({ message: 'Prompt is too long. Maximum 2000 characters.', code: 'MAX_LENGTH_EXCEEDED' });
          return;
        }

        const userPrompt = value.trim();

        // Call parent's onSubmit handler with the prompt (parent will clear value)
        onSubmit(userPrompt);
      }, [value, setValidationError, onSubmit]);

      // Story 2.4: Disable input during chat loading OR improvement generation
      const isDisabled = isLoading || isGeneratingImprovement;

      return (
        <>
          {error && <RetryButton error={error} onRetry={onRetry} isRetrying={isRetrying} />}
          <form className="chat-interface__input-form" onSubmit={handleSubmit}>
            <input
              ref={inputRef}
              className={`chat-interface__input-field${isHighlighted ? ' chat-interface__input-field--highlighted' : ''}`}
              type="text"
              value={value}
              onChange={handleChange}
              placeholder={isGeneratingImprovement ? "Please wait while we generate your improvement..." : "Enter your prompt..."}
              disabled={isDisabled}
            />
            <Button
              onClick={handleSubmit}
              disabled={isDisabled || !value.trim()}
            >
              {isLoading ? 'Sending...' : 'Send'}
            </Button>
          </form>
          {validationError && <ValidationError error={validationError} />}
        </>
      );
    });

    // ResetConfirmationModal - Layout component (Story 5.3)
    // Optional modal for confirming destructive reset action
    // Props: isOpen (boolean), onConfirm (callback), onCancel (callback)
    // Accessibility: Focus trap, ESC key, keyboard navigation, screen reader support
    const ResetConfirmationModal = React.memo(({ isOpen, onConfirm, onCancel }) => {
      const modalRef = React.useRef(null);

      // ESC key handler and keyboard focus trap
      React.useEffect(() => {
        const handleEscape = (e) => {
          if (e.key === 'Escape') {
            onCancel();
          }
        };

        // Focus trap: Tab key cycles within modal only
        const handleTab = (e) => {
          if (e.key === 'Tab') {
            if (!modalRef.current) return;

            const focusableElements = modalRef.current.querySelectorAll(
              'button, [tabindex]:not([tabindex="-1"])'
            );

            if (focusableElements.length === 0) return;

            const firstElement = focusableElements[0];
            const lastElement = focusableElements[focusableElements.length - 1];

            if (e.shiftKey) {
              // Shift+Tab: Focus moving backwards
              if (document.activeElement === firstElement) {
                e.preventDefault();
                lastElement.focus();
              }
            } else {
              // Tab: Focus moving forwards
              if (document.activeElement === lastElement) {
                e.preventDefault();
                firstElement.focus();
              }
            }
          }
        };

        if (isOpen) {
          // Add event listeners
          document.addEventListener('keydown', handleEscape);
          document.addEventListener('keydown', handleTab);

          // Set initial focus to first focusable element
          if (modalRef.current) {
            const firstFocusable = modalRef.current.querySelector(
              'button, [tabindex]:not([tabindex="-1"])'
            );
            firstFocusable?.focus();
          }
        }

        return () => {
          // Cleanup: remove event listeners
          document.removeEventListener('keydown', handleEscape);
          document.removeEventListener('keydown', handleTab);
        };
      }, [isOpen, onCancel]);

      // Guard clause - don't render if closed
      if (!isOpen) return null;

      const handleOverlayClick = (e) => {
        // Close only if overlay is clicked, not modal container
        if (e.target.classList.contains('reset-modal__overlay')) {
          onCancel();
        }
      };

      return (
        <div className="reset-modal__overlay" onClick={handleOverlayClick}>
          <div
            ref={modalRef}
            className="reset-modal"
            role="dialog"
            aria-modal="true"
            aria-labelledby="reset-modal-title"
            aria-describedby="reset-modal-description"
          >
            {/* Modal Header */}
            <div className="reset-modal__header">
              <h2 id="reset-modal-title" className="reset-modal__title">
                Clear Chat History?
              </h2>
            </div>

            {/* Modal Body */}
            <div className="reset-modal__body">
              <p id="reset-modal-description" className="reset-modal__message">
                This will clear all chat history and you'll start fresh. This action cannot be undone.
              </p>
            </div>

            {/* Modal Footer */}
            <div className="reset-modal__footer">
              <button
                className="reset-modal__button reset-modal__button--cancel"
                onClick={onCancel}
              >
                Cancel
              </button>
              <button
                className="reset-modal__button reset-modal__button--confirm"
                onClick={onConfirm}
              >
                Clear History
              </button>
            </div>
          </div>
        </div>
      );
    });

    // LAYOUT COMPONENT (defined last)

    // ChatInterface - Main chat layout with message list and input
    // AC #5: ChatInterface component using useAppContext
    // Story 2.1: Added logic to find most recent AI message and handle "Not Satisfied" button
    // Story 2.4: Added LoadingIndicator for feedback processing state
    // Story 5.1: Accept controlled input props from App
    // Story 5.3: Add header with reset button and confirmation modal
    // Story 5.4: Added isRetrying state for retry debouncing
    const ChatInterface = ({ chatInputValue, setChatInputValue, chatInputRef, isInputHighlighted, onReset }) => {
      const { chatHistory, isChatLoading, chatError, addMessage, setChatError, setIsChatLoading, setValidationError, isFeedbackModalOpen, setIsFeedbackModalOpen, setIsComparisonModalOpen, setRecentFeedback, isGeneratingImprovement } = useAppContext();
      const [pendingPrompt, setPendingPrompt] = React.useState(null);
      const [isRetrying, setIsRetrying] = React.useState(false);

      // Story 5.3: Local state for reset confirmation modal
      const [showResetConfirm, setShowResetConfirm] = React.useState(false);

      // Story 2.1: Find most recent AI response for "Not Satisfied" button
      const getMostRecentAIMessage = React.useCallback(() => {
        const aiMessages = chatHistory.filter(msg => msg.role === 'assistant');
        return aiMessages.length > 0 ? aiMessages[aiMessages.length - 1] : null;
      }, [chatHistory]);

      const mostRecentAIMessage = getMostRecentAIMessage();

      // Story 2.1: Handle "Not Satisfied" button click
      // Opens feedback modal - Story 2.3 will capture feedback data on submit
      const handleNotSatisfied = React.useCallback(() => {
        // Close comparison modal if open (it shouldn't be, but defensive)
        setIsComparisonModalOpen(false);
        // Open feedback modal
        setIsFeedbackModalOpen(true);
      }, [setIsFeedbackModalOpen, setIsComparisonModalOpen]);

      // Story 5.3: Handle reset button click
      // Show confirmation if there are messages, otherwise reset immediately
      const handleResetClick = React.useCallback(() => {
        if (chatHistory && chatHistory.length > 0) {
          setShowResetConfirm(true);
        } else {
          // No messages, reset immediately
          onReset();
        }
      }, [chatHistory, onReset]);

      // Story 5.3: Confirm reset action
      const handleConfirmReset = React.useCallback(() => {
        setShowResetConfirm(false);
        onReset();
      }, [onReset]);

      // Story 5.3: Cancel reset action
      const handleCancelReset = React.useCallback(() => {
        setShowResetConfirm(false);
      }, []);

      // API integration submit handler - Story 1.4 implementation with retry support
      // Story 5.4: Enhanced with formatError for comprehensive error handling
      // Optimized with useCallback to prevent unnecessary re-renders
      const handleSubmit = React.useCallback(async (userPrompt) => {
        try {
          // Store prompt for potential retry
          setPendingPrompt(userPrompt);

          // Add user message to chat history
          addMessage({ role: 'user', content: userPrompt });

          // Story 5.1: Clear input after submission
          setChatInputValue('');

          // Clear validation and error on new submission
          setValidationError(null);
          setChatError(null);

          // Set loading state
          setIsChatLoading(true);

          // Call API
          const aiResponse = await callChatAPI(userPrompt);

          // Add AI response to chat history
          addMessage({ role: 'assistant', content: aiResponse });

          // Clear error on success
          setChatError(null);
          setPendingPrompt(null);
        } catch (error) {
          // Story 5.4: Format error for user-friendly display
          const formattedError = formatError(error);
          setChatError(formattedError);
          console.error('Chat API error:', formattedError);
        } finally {
          // Always clear loading state
          setIsChatLoading(false);
        }
      }, [addMessage, setChatError, setIsChatLoading, setValidationError, setChatInputValue]);

      // Story 5.4: Retry handler with debouncing to prevent race conditions
      const handleRetry = React.useCallback(async () => {
        if (pendingPrompt && !isRetrying && !isChatLoading) {
          setIsRetrying(true);
          setChatError(null); // Clear error before retry
          try {
            await handleSubmit(pendingPrompt);
          } finally {
            setIsRetrying(false);
          }
        }
      }, [pendingPrompt, isRetrying, isChatLoading, setChatError, handleSubmit]);

      return (
        <div className="chat-interface">
          {/* Story 5.3: Header with title and reset button */}
          <div className="chat-interface__header">
            <h1 className="chat-interface__title">DigitalWave Test</h1>
            <button
              className="chat-interface__reset-button"
              onClick={handleResetClick}
              aria-label="Clear chat history and start fresh"
            >
              Start Fresh
            </button>
          </div>

          <MessageList
            messages={chatHistory}
            mostRecentAIMessage={mostRecentAIMessage}
            onNotSatisfied={handleNotSatisfied}
            isFeedbackModalOpen={isFeedbackModalOpen}
            isGeneratingImprovement={isGeneratingImprovement}
          />

          {/* Story 2.4: Loading Indicator - Shows when improvement is being generated */}
          {isGeneratingImprovement && (
            <LoadingIndicator message="Generating improvement..." />
          )}

          <div className="chat-interface__input-container">
            <ChatInput
              ref={chatInputRef}
              onSubmit={handleSubmit}
              isLoading={isChatLoading}
              value={chatInputValue}
              onChange={setChatInputValue}
              isHighlighted={isInputHighlighted}
              error={chatError}
              onRetry={handleRetry}
              isRetrying={isRetrying}
            />
          </div>

          {/* Story 5.3: Reset Confirmation Modal */}
          <ResetConfirmationModal
            isOpen={showResetConfirm}
            onConfirm={handleConfirmReset}
            onCancel={handleCancelReset}
          />
        </div>
      );
    };

    // FeedbackModal - Layout component (Story 2.2)
    // Modal dialog for collecting user feedback about AI responses
    // Props: isOpen (boolean), onClose (callback), onSubmit (callback with feedbackText)
    // Story 5.4: Added error and onRetry props for error display with retry
    // Architecture: feedbackText stored in LOCAL state (not context) - form data should be
    // ephemeral and component-scoped, not polluting global state
    const FeedbackModal = ({ isOpen, onClose, onSubmit, error, onRetry }) => {
      const [feedbackText, setFeedbackText] = React.useState('');
      const [isSubmitting, setIsSubmitting] = React.useState(false);
      const textareaRef = React.useRef(null);

      // Define handleClose with useCallback to prevent ESC effect from re-running unnecessarily
      const handleClose = React.useCallback(() => {
        setFeedbackText(''); // Clear feedback text
        setIsSubmitting(false); // Reset submitting state
        onClose(); // Call parent callback
      }, [onClose]);

      // Auto-focus textarea when modal opens
      // Clear feedback text when modal opens for fresh input
      React.useEffect(() => {
        if (isOpen && textareaRef.current) {
          textareaRef.current.focus();
          setFeedbackText(''); // Clear old feedback when modal opens
        }
      }, [isOpen]);

      // ESC key handler - now safe with handleClose memoized
      React.useEffect(() => {
        const handleEsc = (event) => {
          if (event.key === 'Escape' && isOpen) {
            handleClose();
          }
        };

        document.addEventListener('keydown', handleEsc);
        return () => document.removeEventListener('keydown', handleEsc);
      }, [isOpen, handleClose]);

      const handleSubmit = () => {
        // Guard against double submission
        if (isSubmitting) return;

        // Validate feedback text
        if (!feedbackText.trim()) {
          return; // Button should be disabled, but defensive check
        }

        // Set submitting state
        setIsSubmitting(true);

        // Call parent submit handler
        onSubmit(feedbackText);

        // Note: Modal will close via parent's setIsFeedbackModalOpen(false)
        // State will be reset when modal closes via handleClose
      };

      const handleOverlayClick = (event) => {
        // Close only if overlay is clicked, not modal container
        if (event.target === event.currentTarget) {
          handleClose();
        }
      };

      if (!isOpen) return null;

      return (
        <div className="feedback-modal__overlay" onClick={handleOverlayClick}>
          <div
            className="feedback-modal"
            role="dialog"
            aria-labelledby="feedback-modal-title"
            aria-describedby="feedback-modal-description"
          >
            {/* Header */}
            <div className="feedback-modal__header">
              <h2 id="feedback-modal-title">Let's improve this result</h2>
            </div>

            {/* Body */}
            <div className="feedback-modal__body">
              <textarea
                ref={textareaRef}
                id="feedback-modal-description"
                className="feedback-modal__textarea"
                placeholder="What didn't you like about this result?"
                value={feedbackText}
                onChange={(e) => setFeedbackText(e.target.value)}
                rows={3}
                maxLength={500}
                aria-label="Feedback input"
                disabled={isSubmitting}
              />
              {error && <RetryButton error={error} onRetry={onRetry} />}
              <p
                className={`feedback-modal__char-counter ${
                  feedbackText.length > 450 ? 'feedback-modal__char-counter--danger' :
                  feedbackText.length > 400 ? 'feedback-modal__char-counter--warning' : ''
                }`}
              >
                {feedbackText.length} / 500 characters
              </p>
            </div>

            {/* Footer */}
            <div className="feedback-modal__footer">
              <button
                className="feedback-modal__cancel-button"
                onClick={handleClose}
                disabled={isSubmitting}
              >
                Cancel
              </button>
              <button
                className="feedback-modal__submit-button"
                onClick={handleSubmit}
                disabled={!feedbackText.trim() || isSubmitting}
              >
                {isSubmitting ? 'Generating...' : 'Generate Improved Prompt'}
              </button>
            </div>
          </div>
        </div>
      );
    };

    // ComparisonModal - Layout component (Story 4.1)
    // Modal for side-by-side comparison of original vs improved prompts
    // Props: isOpen (boolean), comparisonData (object with originalPrompt, improvedPrompt), onClose (callback)
    // Story 4.2: Enhanced with HighlightedText component for improved prompt highlighting
    // Story 4.4: Enhanced with educational tooltips on improved prompt
    const ComparisonModal = ({ isOpen, comparisonData, onClose, onUsePrompt }) => {
      const modalRef = React.useRef(null);
      const triggerElementRef = React.useRef(null);

      // Story 5.1: State for button loading
      const [isInserting, setIsInserting] = React.useState(false);

      // Story 5.1: Handle "Use This Prompt" button click
      // Code Review Fix: Added null check and increased timeout to match modal animation
      const handleUsePrompt = React.useCallback(() => {
        // Code Review Fix: Null check for comparisonData
        if (!comparisonData || !comparisonData.improvedPrompt) {
          console.error('No improved prompt available');
          return;
        }

        setIsInserting(true);

        // Extract improved prompt from comparison data
        const { improvedPrompt } = comparisonData;

        // Call parent callback to insert prompt into chat input
        if (onUsePrompt) {
          onUsePrompt(improvedPrompt);
        }

        // Close modal
        onClose();

        // Code Review Fix: Increased timeout to 300ms to match modal close animation duration
        setTimeout(() => setIsInserting(false), 300);
      }, [comparisonData, onUsePrompt, onClose]);

      // ESC key handler and keyboard focus trap
      React.useEffect(() => {
        const handleEscape = (e) => {
          if (e.key === 'Escape') {
            onClose();
          }
        };

        // Focus trap: Tab key cycles within modal only
        const handleTab = (e) => {
          if (e.key === 'Tab') {
            if (!modalRef.current) return;

            const focusableElements = modalRef.current.querySelectorAll(
              'button, [tabindex]:not([tabindex="-1"])'
            );

            if (focusableElements.length === 0) return;

            const firstElement = focusableElements[0];
            const lastElement = focusableElements[focusableElements.length - 1];

            if (e.shiftKey) {
              // Shift+Tab: Focus moving backwards
              if (document.activeElement === firstElement) {
                e.preventDefault();
                lastElement.focus();
              }
            } else {
              // Tab: Focus moving forwards
              if (document.activeElement === lastElement) {
                e.preventDefault();
                firstElement.focus();
              }
            }
          }
        };

        if (isOpen) {
          // Store trigger element for focus restoration
          triggerElementRef.current = document.activeElement;

          // Add event listeners
          document.addEventListener('keydown', handleEscape);
          document.addEventListener('keydown', handleTab);

          // Set initial focus to first focusable element
          if (modalRef.current) {
            const firstFocusable = modalRef.current.querySelector(
              'button, [tabindex]:not([tabindex="-1"])'
            );
            firstFocusable?.focus();
          }
        }

        return () => {
          // Cleanup: remove event listeners
          document.removeEventListener('keydown', handleEscape);
          document.removeEventListener('keydown', handleTab);

          // Return focus to trigger element when modal closes
          if (triggerElementRef.current) {
            triggerElementRef.current.focus();
          }
        };
      }, [isOpen, onClose]);

      // Guard clause - don't render if closed or no data
      if (!isOpen || !comparisonData) {
        return null;
      }

      // Story 4.2: Parse improved prompt for highlights (after guard clause, safe to access comparisonData)
      const highlights = parseImprovedPrompt(comparisonData.improvedPrompt);

      // Story 4.4: Extract explanations for tooltips (after guard clause, safe to access comparisonData)
      const explanations = comparisonData.explanations || [];

      // Overlay click handler
      const handleOverlayClick = (e) => {
        if (e.target.classList.contains('comparison-modal__overlay')) {
          onClose();
        }
      };

      return (
        <div className="comparison-modal__overlay" onClick={handleOverlayClick}>
          <div ref={modalRef} className="comparison-modal" role="dialog" aria-modal="true" aria-labelledby="modal-title">
            {/* Modal Header */}
            <div className="comparison-modal__header">
              <h2 id="modal-title" className="comparison-modal__title">
                See how your prompt improved
              </h2>
              <button
                className="comparison-modal__close-button"
                onClick={onClose}
                aria-label="Close modal"
              >
                
              </button>
            </div>

            {/* Modal Body - Two Column Layout */}
            <div className="comparison-modal__body">
              {/* Left Column - Original Prompt */}
              <div className="comparison-modal__column comparison-modal__column--original">
                <h3 className="comparison-modal__column-header">
                  Your Original Prompt
                </h3>
                <div className="comparison-modal__content">
                  <p className="comparison-modal__prompt-text">
                    {comparisonData.originalPrompt}
                  </p>
                </div>
              </div>

              {/* Right Column - Improved Prompt (Story 4.2: WITH HIGHLIGHTING, Story 4.4: WITH EDUCATIONAL TOOLTIPS) */}
              <div className="comparison-modal__column comparison-modal__column--improved">
                <h3 className="comparison-modal__column-header comparison-modal__column-header--improved">
                  Improved Version
                </h3>
                <div className="comparison-modal__content">
                  {/* Story 4.4: Pass explanations prop for educational tooltips on improved prompt */}
                  <ImprovedPromptWithBadges
                    text={comparisonData.improvedPrompt}
                    highlights={highlights}
                    explanations={explanations}
                  />
                </div>
              </div>
            </div>

            {/* Modal Footer - Use This Prompt Button */}
            <div className="comparison-modal__footer">
              <button
                className="comparison-modal__use-button"
                onClick={handleUsePrompt}
                disabled={isInserting}
                aria-label="Use this improved prompt"
              >
                {isInserting ? 'Inserting...' : 'Use This Prompt'}
              </button>
            </div>
          </div>
        </div>
      );
    };

    // ============================================================
    // SECTION 5: CONTEXT PROVIDER
    // ============================================================

    // AppContext - Global application state
    const AppContext = React.createContext(null);

    // AC #2: AppProvider component with useState hooks and context value
    const AppProvider = ({ children }) => {
      // AC #1: Complete state structure
      // Chat state
      const [chatHistory, setChatHistory] = React.useState([]);
      const [isChatLoading, setIsChatLoading] = React.useState(false);
      const [chatError, setChatError] = React.useState(null);

      // Story 1.5: Validation state
      const [validationError, setValidationError] = React.useState(null);

      // Modal states
      const [isFeedbackModalOpen, setIsFeedbackModalOpen] = React.useState(false);
      const [isComparisonModalOpen, setIsComparisonModalOpen] = React.useState(false);
      const [comparisonData, setComparisonData] = React.useState(null);

      // Improvement state
      const [isGeneratingImprovement, setIsGeneratingImprovement] = React.useState(false);
      const [improvementError, setImprovementError] = React.useState(null);

      // Feedback context
      const [recentFeedback, setRecentFeedback] = React.useState(null);

      // Story 4.1: Close comparison modal handler
      const handleCloseComparisonModal = () => {
        setIsComparisonModalOpen(false);
        // Optionally clear comparisonData
        // setComparisonData(null);
      };

      // AC #3: Immutable state update helpers
      const addMessage = (message) => {
        setChatHistory(prev => [...prev, message]);
      };

      const clearChat = () => {
        setChatHistory([]);
        setChatError(null);
        setRecentFeedback(null);
        setComparisonData(null);
      };

      // Memoize context value to prevent unnecessary re-renders
      const value = React.useMemo(() => ({
        // State values
        chatHistory,
        isChatLoading,
        chatError,
        validationError,
        isFeedbackModalOpen,
        isComparisonModalOpen,
        comparisonData,
        isGeneratingImprovement,
        improvementError,
        recentFeedback,
        // State updaters
        setChatHistory,
        setIsChatLoading,
        setChatError,
        setValidationError,
        setIsFeedbackModalOpen,
        setIsComparisonModalOpen,
        setComparisonData,
        setIsGeneratingImprovement,
        setImprovementError,
        setRecentFeedback,
        // Helper functions
        addMessage,
        clearChat,
        handleCloseComparisonModal
      }), [
        chatHistory,
        isChatLoading,
        chatError,
        validationError,
        isFeedbackModalOpen,
        isComparisonModalOpen,
        comparisonData,
        isGeneratingImprovement,
        improvementError,
        recentFeedback
      ]);

      return (
        <AppContext.Provider value={value}>
          {children}
        </AppContext.Provider>
      );
    };

    // ============================================================
    // SECTION 6: MAIN APP COMPONENT
    // ============================================================
    const App = () => {
      const {
        isFeedbackModalOpen,
        setIsFeedbackModalOpen,
        isComparisonModalOpen,
        setIsComparisonModalOpen,
        comparisonData,
        setComparisonData,
        handleCloseComparisonModal,
        chatHistory,
        setRecentFeedback,
        setIsGeneratingImprovement,
        improvementError,
        setImprovementError,
        setChatHistory,
        setChatError,
        setIsChatLoading,
        addMessage
      } = useAppContext();

      // Story 5.1: State for controlled chat input value
      const [chatInputValue, setChatInputValue] = React.useState('');

      // Story 5.1: Ref for ChatInput component (to call focus method)
      const chatInputRef = React.useRef(null);

      // Story 5.1: State for visual highlight animation
      const [isInputHighlighted, setIsInputHighlighted] = React.useState(false);

      // Code Review Fix: Refs for timeout cleanup
      const highlightTimeoutRef = React.useRef(null);
      const focusTimeoutRef = React.useRef(null);
      const announcementTimeoutRef = React.useRef(null);
      const resetAnnouncementTimeoutRef = React.useRef(null);

      // Code Review Fix: Named constants for magic numbers
      const FOCUS_DELAY_MS = 100;
      const ANNOUNCEMENT_DURATION_MS = 1000;

      const handleFeedbackClose = () => {
        setIsFeedbackModalOpen(false);
      };

      // Story 5.3: Handle session reset
      // Clears all application state to initial values
      const handleSessionReset = React.useCallback(() => {
        const resetStartTime = performance.now();

        // Clear chat history
        setChatHistory([]);

        // Clear input field
        setChatInputValue('');

        // Clear all modal states
        setIsFeedbackModalOpen(false);
        setIsComparisonModalOpen(false);
        setComparisonData(null);

        // Clear error states
        setChatError(null);
        setImprovementError(null);

        // Clear loading states (should already be false, but ensure)
        setIsChatLoading(false);

        // Clear feedback context
        setRecentFeedback(null);

        // Focus input field after reset
        if (focusTimeoutRef.current) {
          clearTimeout(focusTimeoutRef.current);
        }
        focusTimeoutRef.current = setTimeout(() => {
          try {
            if (chatInputRef.current && chatInputRef.current.focus) {
              chatInputRef.current.focus();
            }
          } catch (error) {
            console.warn('Failed to focus input after reset:', error);
          }
          focusTimeoutRef.current = null;
        }, FOCUS_DELAY_MS);

        // Screen reader announcement
        if (resetAnnouncementTimeoutRef.current) {
          clearTimeout(resetAnnouncementTimeoutRef.current);
        }
        const announcement = document.createElement('div');
        announcement.setAttribute('role', 'status');
        announcement.setAttribute('aria-live', 'polite');
        announcement.textContent = 'Chat history cleared';
        document.body.appendChild(announcement);

        resetAnnouncementTimeoutRef.current = setTimeout(() => {
          if (document.body.contains(announcement)) {
            document.body.removeChild(announcement);
          }
          resetAnnouncementTimeoutRef.current = null;
        }, ANNOUNCEMENT_DURATION_MS);

        // Performance logging (verify <100ms per NFR-P1)
        const resetEndTime = performance.now();
        const resetTime = resetEndTime - resetStartTime;
        if (resetTime > 100) {
          console.warn(`Session reset took ${resetTime.toFixed(2)}ms (target: <100ms per NFR-P1)`);
        }
      }, [
        setChatHistory,
        setChatInputValue,
        setIsFeedbackModalOpen,
        setIsComparisonModalOpen,
        setComparisonData,
        setChatError,
        setImprovementError,
        setIsChatLoading,
        setRecentFeedback,
        chatInputRef
      ]);

      // Story 5.4: State for storing last improvement parameters for retry
      const [lastImprovementParams, setLastImprovementParams] = React.useState(null);

      const handleFeedbackSubmit = async (feedbackText) => {
        // Extract most recent messages from chat history
        // Find last user message
        const userMessages = chatHistory.filter(msg => msg.role === 'user');
        const lastUserMessage = userMessages[userMessages.length - 1];

        // Find last assistant message
        const assistantMessages = chatHistory.filter(msg => msg.role === 'assistant');
        const lastAssistantMessage = assistantMessages[assistantMessages.length - 1];

        // Edge case: No messages (shouldn't happen, but defensive)
        if (!lastUserMessage || !lastAssistantMessage) {
          console.error('No messages found in chat history');
          return;
        }

        // Create feedback object
        const feedback = {
          userPrompt: lastUserMessage.content,
          aiResponse: lastAssistantMessage.content,
          feedbackText: feedbackText,
          timestamp: Date.now()
        };

        // Store feedback in context
        setRecentFeedback(feedback);

        // Story 5.4: Store parameters for retry
        setLastImprovementParams({
          originalPrompt: feedback.userPrompt,
          userFeedback: feedback.feedbackText
        });

        // Clear any previous improvement errors
        setImprovementError(null);

        // Trigger improvement generation state
        setIsGeneratingImprovement(true);

        // Close feedback modal
        setIsFeedbackModalOpen(false);

        try {
          // Call improvement API (Story 3.1 implementation)
          const { improvedPrompt, mapping, explanations } = await generateImprovement(
            feedback.userPrompt,
            feedback.feedbackText
          );

          // Store improvement data in context (for Epic 4 comparison modal)
          setComparisonData({
            originalPrompt: feedback.userPrompt,
            improvedPrompt: improvedPrompt,
            mapping: mapping,
            explanations: explanations
          });

          // Clear loading state
          setIsGeneratingImprovement(false);

          // Open comparison modal (Epic 4 will implement the modal)
          setIsComparisonModalOpen(true);

        } catch (error) {
          // Story 5.4: Format error for user-friendly display
          const formattedError = formatError(error);
          console.error('Improvement generation failed:', formattedError);

          // Clear loading state
          setIsGeneratingImprovement(false);

          // Show error in UI (reopen modal for retry)
          setImprovementError(formattedError);
          setIsFeedbackModalOpen(true); // Reopen modal to show error
        }
      };

      // Story 5.4: Handle improvement generation retry
      const handleRetryImprovement = React.useCallback(async () => {
        if (lastImprovementParams) {
          setImprovementError(null); // Clear error before retry
          setIsGeneratingImprovement(true);

          try {
            const { improvedPrompt, mapping, explanations } = await generateImprovement(
              lastImprovementParams.originalPrompt,
              lastImprovementParams.userFeedback
            );

            setComparisonData({
              originalPrompt: lastImprovementParams.originalPrompt,
              improvedPrompt: improvedPrompt,
              mapping: mapping,
              explanations: explanations
            });

            setIsGeneratingImprovement(false);
            setIsFeedbackModalOpen(false); // Close modal on success
            setIsComparisonModalOpen(true);
          } catch (error) {
            const formattedError = formatError(error);
            console.error('Improvement retry failed:', formattedError);
            setIsGeneratingImprovement(false);
            setImprovementError(formattedError);
            // Modal stays open for another retry
          }
        }
      }, [lastImprovementParams, setImprovementError, setIsGeneratingImprovement, setIsFeedbackModalOpen, setIsComparisonModalOpen, setComparisonData]);

      // Story 5.1: Handle "Use This Prompt" button click
      // Code Review Fix: Added all dependencies, timeout cleanup, error handling
      const handleUseImprovedPrompt = React.useCallback((improvedPrompt) => {
        // Format improved prompt: replace multiple newlines with "; " for single-line display
        const formattedPrompt = improvedPrompt.replace(/\n\n+/g, '; ');

        // Close comparison modal
        setIsComparisonModalOpen(false);

        // Clear ALL improvement-related state to allow fresh re-improvement cycle
        // Use setTimeout to ensure state updates are flushed before modal can open
        setTimeout(() => {
          setImprovementError(null);
          setComparisonData(null);
          setIsGeneratingImprovement(false);
          setRecentFeedback(null); // Clear old feedback data
          setLastImprovementParams(null); // Clear old improvement parameters
        }, 0);

        // Submit the improved prompt directly to get new AI response
        // This updates chat history so "Not Satisfied" works on the new response
        const submitPromptAsync = async () => {
          try {
            // Add user message to chat history
            addMessage({ role: 'user', content: formattedPrompt });

            // Clear input
            setChatInputValue('');

            // Set loading state
            setIsChatLoading(true);

            // Call API
            const aiResponse = await callChatAPI(formattedPrompt);

            // Add AI response to chat history
            addMessage({ role: 'assistant', content: aiResponse });
          } catch (error) {
            const formattedError = formatError(error);
            setChatError(formattedError);
            console.error('Chat API error after using improved prompt:', formattedError);
          } finally {
            setIsChatLoading(false);
          }
        };

        // Execute the submission
        submitPromptAsync();

        // Code Review Fix: Clear existing highlight timeout before setting new one
        if (highlightTimeoutRef.current) {
          clearTimeout(highlightTimeoutRef.current);
        }

        // Add visual highlight flash to input field
        setIsInputHighlighted(true);
        highlightTimeoutRef.current = setTimeout(() => {
          setIsInputHighlighted(false);
          highlightTimeoutRef.current = null;
        }, 600); // Remove after animation

        // Code Review Fix: Clear existing focus timeout before setting new one
        if (focusTimeoutRef.current) {
          clearTimeout(focusTimeoutRef.current);
        }

        // Focus input field after modal closes
        focusTimeoutRef.current = setTimeout(() => {
          try {
            if (chatInputRef.current && chatInputRef.current.focus) {
              chatInputRef.current.focus();
            }
          } catch (error) {
            console.warn('Failed to focus input:', error);
          }
          focusTimeoutRef.current = null;
        }, 150); // Small delay to allow modal close animation

        // Code Review Fix: Clear existing announcement timeout before creating new one
        if (announcementTimeoutRef.current) {
          clearTimeout(announcementTimeoutRef.current);
        }

        // Announce to screen readers
        const announcement = document.createElement('div');
        announcement.setAttribute('role', 'status');
        announcement.setAttribute('aria-live', 'polite');
        announcement.textContent = 'Improved prompt inserted into input field';
        document.body.appendChild(announcement);

        announcementTimeoutRef.current = setTimeout(() => {
          if (document.body.contains(announcement)) {
            document.body.removeChild(announcement);
          }
          announcementTimeoutRef.current = null;
        }, 1000);
      }, [setIsComparisonModalOpen, setChatInputValue, setImprovementError, setComparisonData, setIsGeneratingImprovement, addMessage, setIsChatLoading, setChatError, setIsInputHighlighted, chatInputRef]);

      return (
        <div className="app-container">
          <ChatInterface
            chatInputValue={chatInputValue}
            setChatInputValue={setChatInputValue}
            chatInputRef={chatInputRef}
            isInputHighlighted={isInputHighlighted}
            onReset={handleSessionReset}
          />

          {/* Feedback Modal - Story 5.4: Added error and retry handling */}
          <FeedbackModal
            isOpen={isFeedbackModalOpen}
            onClose={handleFeedbackClose}
            onSubmit={handleFeedbackSubmit}
            error={improvementError}
            onRetry={handleRetryImprovement}
          />

          {/* Story 4.1: Comparison Modal */}
          <ComparisonModal
            isOpen={isComparisonModalOpen}
            comparisonData={comparisonData}
            onClose={handleCloseComparisonModal}
            onUsePrompt={handleUseImprovedPrompt}
          />
        </div>
      );
    };

    // ============================================================
    // SECTION 7: RENDER
    // ============================================================
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      <AppProvider>
        <ErrorBoundary>
          <App />
        </ErrorBoundary>
      </AppProvider>
    );
  </script>
</body>
</html>
