<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DigitalWaveTest</title>

  <!-- React 18.x CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Babel Standalone -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    /* CSS Custom Properties */
    :root {
      --color-primary: #0066cc;
      --color-background: #f5f5f5;
      --color-text: #333333;
      --spacing-unit: 8px;
      --border-radius: 4px;
    }

    /* Global Reset */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    /* Body Styles */
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background-color: var(--color-background);
      color: var(--color-text);
      line-height: 1.6;
      min-width: 1024px;
    }

    /* App Container */
    .app-container {
      padding: calc(var(--spacing-unit) * 4);
      text-align: center;
    }

    .app-container__title {
      color: var(--color-primary);
    }

    /* Error Boundary */
    .error-boundary {
      padding: calc(var(--spacing-unit) * 4);
      text-align: center;
      background-color: #fee;
      border: 1px solid #c00;
      border-radius: var(--border-radius);
      margin: calc(var(--spacing-unit) * 2);
    }

    .error-boundary__title {
      color: #c00;
      margin-bottom: var(--spacing-unit);
    }

    .error-boundary__message {
      color: var(--color-text);
    }

    .error-boundary__button {
      margin-top: calc(var(--spacing-unit) * 2);
      padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
      background-color: var(--color-primary);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
    }

    .error-boundary__button:hover {
      opacity: 0.9;
    }

    /* Chat Interface Component */
    .chat-interface {
      display: flex;
      flex-direction: column;
      height: calc(100vh - calc(var(--spacing-unit) * 8));
      max-width: 900px;
      margin: 0 auto;
      background-color: #ffffff;
      border-radius: var(--border-radius);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    /* Message List Component */
    .chat-interface__message-list {
      flex: 1;
      overflow-y: auto;
      padding: calc(var(--spacing-unit) * 3);
      display: flex;
      flex-direction: column;
      gap: calc(var(--spacing-unit) * 2);
    }

    .chat-interface__empty-state {
      text-align: center;
      color: #999;
      padding: calc(var(--spacing-unit) * 8) calc(var(--spacing-unit) * 4);
      font-size: 16px;
    }

    /* Message Bubble Component */
    .chat-interface__message {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      margin-bottom: calc(var(--spacing-unit) * 2);
    }

    .chat-interface__message--sent {
      align-items: flex-end;
    }

    .chat-interface__message--received {
      align-items: flex-start;
    }

    .chat-interface__message-content {
      max-width: 70%;
      padding: calc(var(--spacing-unit) * 2) calc(var(--spacing-unit) * 3);
      border-radius: calc(var(--spacing-unit) * 2);
      word-wrap: break-word;
      line-height: 1.5;
    }

    .chat-interface__message--sent .chat-interface__message-content {
      background-color: var(--color-primary);
      color: #ffffff;
    }

    .chat-interface__message--received .chat-interface__message-content {
      background-color: #f0f0f0;
      color: var(--color-text);
    }

    /* Input Container */
    .chat-interface__input-container {
      padding: calc(var(--spacing-unit) * 3);
      border-top: 1px solid #e0e0e0;
      background-color: #ffffff;
    }

    /* Chat Input Form */
    .chat-interface__input-form {
      display: flex;
      gap: calc(var(--spacing-unit) * 2);
      align-items: center;
    }

    /* Input Field */
    .chat-interface__input-field {
      flex: 1;
      padding: calc(var(--spacing-unit) * 2) calc(var(--spacing-unit) * 3);
      border: 2px solid #e0e0e0;
      border-radius: var(--border-radius);
      font-size: 16px;
      font-family: inherit;
      outline: none;
      transition: border-color 0.2s ease;
    }

    .chat-interface__input-field:focus {
      border-color: var(--color-primary);
    }

    .chat-interface__input-field:disabled {
      background-color: #f5f5f5;
      cursor: not-allowed;
    }

    /* Button Component */
    .chat-interface__button {
      padding: calc(var(--spacing-unit) * 2) calc(var(--spacing-unit) * 4);
      background-color: var(--color-primary);
      color: #ffffff;
      border: none;
      border-radius: var(--border-radius);
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: opacity 0.2s ease;
      white-space: nowrap;
    }

    .chat-interface__button:hover:not(:disabled) {
      opacity: 0.9;
    }

    .chat-interface__button--disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .chat-interface__button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Validation Error (Story 1.5) */
    .chat-interface__validation-error {
      padding: calc(var(--spacing-unit) * 1) calc(var(--spacing-unit) * 2);
      margin-top: calc(var(--spacing-unit) * 1);
      background-color: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: var(--border-radius);
    }

    .chat-interface__validation-message {
      color: #856404;
      font-size: 14px;
      margin: 0;
    }

    /* Error Display (Story 1.5) */
    .chat-interface__error-display {
      padding: calc(var(--spacing-unit) * 2) calc(var(--spacing-unit) * 3);
      margin-bottom: calc(var(--spacing-unit) * 2);
      background-color: #f8d7da;
      border: 1px solid #f5c6cb;
      border-radius: var(--border-radius);
      display: flex;
      align-items: center;
      gap: calc(var(--spacing-unit) * 2);
    }

    .chat-interface__error-message {
      color: #721c24;
      font-size: 14px;
      margin: 0;
      flex: 1;
    }

    .chat-interface__retry-button {
      padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
      background-color: var(--color-primary);
      color: #ffffff;
      border: none;
      border-radius: var(--border-radius);
      font-size: 14px;
      cursor: pointer;
      white-space: nowrap;
    }

    .chat-interface__retry-button:hover {
      opacity: 0.9;
    }

    /* Story 2.1: "Not Satisfied" button styling */
    .message-bubble__not-satisfied {
      margin-top: calc(var(--spacing-unit) * 1);
      padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 1.5);
      background-color: transparent;
      border: 1px solid var(--color-primary);
      color: var(--color-primary);
      border-radius: var(--border-radius);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.1s ease-in-out;
    }

    .message-bubble__not-satisfied:hover:not(:disabled) {
      background-color: var(--color-primary);
      color: #ffffff;
      opacity: 0.9;
    }

    /* Story 2.2: Feedback Modal Component styling */
    /* Modal Overlay - Semi-transparent backdrop */
    .feedback-modal__overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    /* Modal Container - Centered box */
    .feedback-modal {
      background-color: #ffffff;
      border-radius: calc(var(--border-radius) * 2);
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    }

    /* Modal Header */
    .feedback-modal__header {
      padding: calc(var(--spacing-unit) * 2);
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }

    .feedback-modal__header h2 {
      margin: 0;
      font-size: 24px;
      color: var(--color-text);
      font-weight: 600;
    }

    /* Modal Body */
    .feedback-modal__body {
      padding: calc(var(--spacing-unit) * 2);
    }

    /* Textarea Input */
    .feedback-modal__textarea {
      width: 100%;
      min-height: 100px;
      padding: calc(var(--spacing-unit) * 1);
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: var(--border-radius);
      font-size: 16px;
      font-family: inherit;
      resize: vertical;
      box-sizing: border-box;
    }

    .feedback-modal__textarea:focus {
      outline: 2px solid var(--color-primary);
      border-color: transparent;
    }

    /* Modal Footer */
    .feedback-modal__footer {
      padding: calc(var(--spacing-unit) * 2);
      border-top: 1px solid rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: flex-end;
      gap: calc(var(--spacing-unit) * 1);
    }

    /* Cancel Button - Secondary style */
    .feedback-modal__cancel-button {
      padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 1.5);
      background-color: transparent;
      border: 1px solid var(--color-primary);
      color: var(--color-primary);
      border-radius: var(--border-radius);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.1s ease-in-out;
    }

    .feedback-modal__cancel-button:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    /* Submit Button - Primary style */
    .feedback-modal__submit-button {
      padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 1.5);
      background-color: var(--color-primary);
      border: none;
      color: #ffffff;
      border-radius: var(--border-radius);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.1s ease-in-out;
    }

    .feedback-modal__submit-button:hover:not(:disabled) {
      opacity: 0.9;
    }

    .feedback-modal__submit-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Character Counter */
    .feedback-modal__char-counter {
      margin-top: calc(var(--spacing-unit) * 0.5);
      font-size: 12px;
      color: #666;
      text-align: right;
    }

    .feedback-modal__char-counter--warning {
      color: #f57c00;
    }

    .feedback-modal__char-counter--danger {
      color: #d32f2f;
    }

    /* Story 2.4: Loading Indicator */
    .chat-interface__loading-indicator {
      display: flex;
      align-items: center;
      gap: var(--spacing-unit);
      padding: var(--spacing-unit);
      margin: var(--spacing-unit) 0;
      background-color: rgba(0, 0, 0, 0.02);
      border-radius: var(--border-radius);
      animation: fadeIn 200ms ease-in;
    }

    .chat-interface__loading-spinner {
      width: 16px;
      height: 16px;
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-top-color: var(--color-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .chat-interface__loading-text {
      color: rgba(0, 0, 0, 0.6);
      font-style: italic;
      font-size: 14px;
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }

    /* Not Satisfied button disabled state */
    .message-bubble__not-satisfied:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background-color: rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    // ============================================================
    // SECTION 1: CONSTANTS & CONFIGURATION
    // ============================================================

    // API Configuration
    const WORKER_URL = 'https://digitalwave-test-proxy.x-gs-x.workers.dev';
    const CHAT_SYSTEM_PROMPT = 
      `You are a helpful assistant. Respond to user prompts naturally.

      You can ONLY assist with product name generation based on the packaging options below. 
      If the user asks about anything else, politely decline and redirect them to select a 
      packaging option for name generation.

      ## Task
      You are testing a product name generation system. The user will select one of four 
      product packaging options below. Based on the packaging description, generate an 
      appropriate product name.

      ## Available Product Packaging Options

      **Option 1 - Condiment Packet:**
      A single-serve foil condiment packet containing ketchup. The packaging features a 
      patriotic red, white, and blue color scheme with a triangular flag-inspired graphic 
      containing stars. The design includes a charitable cause partnership badge and 
      ingredient information printed on the side. The overall aesthetic suggests 
      American-made, family-values branding.

      **Option 2 - Dairy Carton:**
      A gable-top cardboard milk carton with a blue plastic screw cap. The design uses a 
      blue and white color palette with stylized milk splash graphics. Features include a 
      "Natural" diagonal ribbon banner, a circular quality seal badge, and fresh dairy 
      imagery. The typography is clean and modern with rounded lettering.

      **Option 3 - Beverage Cans (Variety Pack):**
      A set of three aluminum soda cans marketed as a healthier alternative. Features 
      retro-style curved script typography as the main logo. Flavors shown: a dark red 
      cola-style variant, a pink cherry cola, and an orange root beer with a float 
      illustration. Each can displays health claims including prebiotics, vitamins, 
      minerals, low sugar content (5-6g), and NON-GMO certification.

      **Option 4 - Cheese Product:**
      Processed cheese slices in a blue plastic and cardboard package. Contains 12 
      individually wrapped slices, 200g total weight. The packaging shows a burger 
      photograph demonstrating product usage. Multilingual text appears in Arabic, English, 
      and Spanish. The brand logo uses a simple, friendly rounded typeface in a dark blue 
      oval.`;
    const API_TIMEOUT = 10000; // 10 seconds
    const MAX_PROMPT_LENGTH = 2000;

    // ============================================================
    // SECTION 2: UTILITY FUNCTIONS
    // ============================================================

    // Error formatting utility - maps technical errors to user-friendly messages
    // Returns error object: { message, code }
    function formatError(error) {
      const errorMessages = {
        'API_TIMEOUT': 'The request took too long. Please try again.',
        'RATE_LIMIT_EXCEEDED': 'We\'re experiencing high demand. Please wait a moment and try again.',
        'INVALID_API_KEY': 'Service configuration error. Please contact support.',
        'NETWORK_ERROR': 'Connection issue. Please check your internet and try again.',
        'UNKNOWN': 'Something went wrong. Please try again.'
      };

      const code = error.code || 'UNKNOWN';
      return {
        message: errorMessages[code] || errorMessages.UNKNOWN,
        code: code
      };
    }

    // Chat API integration - calls Cloudflare Worker proxy
    // Returns: Promise with AI response message
    // Throws: Formatted error object with code and message
    async function callChatAPI(userPrompt) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), API_TIMEOUT);

        const response = await fetch(`${WORKER_URL}/api/chat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt: userPrompt }),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();

        if (!result.success) {
          throw new Error(result.error?.message || 'API call failed');
        }

        return result.data.message;
      } catch (error) {
        if (error.name === 'AbortError') {
          throw formatError({ code: 'API_TIMEOUT' });
        }
        throw formatError(error);
      }
    }

    // ============================================================
    // SECTION 3: CUSTOM HOOKS
    // ============================================================

    // AC #7: useAppContext custom hook with null safety check
    // Note: This hook references AppContext defined in SECTION 5.
    // This works due to JavaScript hoisting and is intentional pattern for hooks.
    const useAppContext = () => {
      const context = React.useContext(AppContext);
      if (context === null) {
        throw new Error('useAppContext must be used within an AppProvider');
      }
      return context;
    };

    // ============================================================
    // SECTION 4: REACT COMPONENTS
    // ============================================================

    // ErrorBoundary - Class component for catching React errors (must be first)
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
      }

      static getDerivedStateFromError(error) {
        return { hasError: true, error };
      }

      componentDidCatch(error, errorInfo) {
        console.error('ErrorBoundary caught an error:', error, errorInfo);
      }

      handleRetry = () => {
        this.setState({ hasError: false, error: null });
      };

      render() {
        if (this.state.hasError) {
          return (
            <div className="error-boundary">
              <h2 className="error-boundary__title">Something went wrong</h2>
              <p className="error-boundary__message">
                The application encountered an unexpected error.
              </p>
              <button className="error-boundary__button" onClick={this.handleRetry}>
                Try Again
              </button>
            </div>
          );
        }

        return this.props.children;
      }
    }

    // LEAF COMPONENTS (defined first)

    // Button - Reusable button component with disabled state
    // AC #1: Button component with children, onClick, disabled, className props
    const Button = ({ children, onClick, disabled = false, className = '' }) => {
      const baseClass = 'chat-interface__button';
      const modifierClass = disabled ? 'chat-interface__button--disabled' : '';
      const combinedClassName = `${baseClass} ${modifierClass} ${className}`.trim().replace(/\s+/g, ' ');

      return (
        <button
          className={combinedClassName}
          onClick={onClick}
          disabled={disabled}
        >
          {children}
        </button>
      );
    };

    // LoadingIndicator - Display loading state with spinner (Story 2.4)
    // Leaf component for showing feedback processing state
    // Props: message (string) - Display text for loading indicator
    const LoadingIndicator = ({ message = "Generating improvement..." }) => {
      return (
        <div className="chat-interface__loading-indicator">
          <div className="chat-interface__loading-spinner"></div>
          <span className="chat-interface__loading-text">{message}</span>
        </div>
      );
    };

    // ValidationError - Display validation error messages (Story 1.5)
    // Leaf component for inline validation feedback
    // Memoized to prevent unnecessary re-renders
    const ValidationError = React.memo(({ error }) => {
      if (!error) return null;

      return (
        <div className="chat-interface__validation-error">
          <p className="chat-interface__validation-message">{error.message}</p>
        </div>
      );
    });

    // ErrorDisplay - Display API error messages with retry button (Story 1.5)
    // Leaf component for API error feedback
    // Memoized to prevent unnecessary re-renders
    const ErrorDisplay = React.memo(({ error, onRetry }) => {
      if (!error) return null;

      const isRetriable = ['API_TIMEOUT', 'NETWORK_ERROR', 'RATE_LIMIT_EXCEEDED'].includes(error.code);

      return (
        <div className="chat-interface__error-display">
          <p className="chat-interface__error-message">{error.message}</p>
          {isRetriable && onRetry && (
            <Button onClick={onRetry} className="chat-interface__retry-button">
              Try Again
            </Button>
          )}
        </div>
      );
    });

    // MessageBubble - Display individual chat message with role-based styling
    // AC #2: MessageBubble component with message object and type prop
    // Story 2.1: Added showNotSatisfiedButton, onNotSatisfied, disabled props for "Not Satisfied" button
    // Story 2.4: Button disabled when isGeneratingImprovement is true
    const MessageBubble = ({ message, type, showNotSatisfiedButton, onNotSatisfied, disabled }) => {
      const typeClass = type === 'sent' ? 'chat-interface__message--sent' : 'chat-interface__message--received';
      const isAI = message.role === 'assistant';

      return (
        <div className={`chat-interface__message ${typeClass}`}>
          <div className="chat-interface__message-content">
            {message.content}
          </div>
          {/* Story 2.1: Conditionally render "Not Satisfied" button on AI messages (outside content div for proper spacing) */}
          {/* Story 2.4: Button disabled during improvement generation */}
          {showNotSatisfiedButton && isAI && (
            <button
              className="message-bubble__not-satisfied"
              onClick={onNotSatisfied}
              disabled={disabled}
            >
              Not Satisfied
            </button>
          )}
        </div>
      );
    };

    // COMPOSITE COMPONENTS (defined after leaf)

    // MessageList - Display list of chat messages with auto-scroll
    // AC #3: MessageList component with auto-scroll and empty state
    // Story 2.1: Added mostRecentAIMessage, onNotSatisfied, isFeedbackModalOpen props for "Not Satisfied" button
    // Story 2.4: Added isGeneratingImprovement to disable button during loading
    const MessageList = ({ messages, mostRecentAIMessage, onNotSatisfied, isFeedbackModalOpen, isGeneratingImprovement }) => {
      const messagesEndRef = React.useRef(null);

      // Auto-scroll to bottom when messages change
      React.useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages]);

      if (messages.length === 0) {
        return (
          <div className="chat-interface__message-list">
            <div className="chat-interface__empty-state">
              No messages yet. Start by entering a prompt.
            </div>
          </div>
        );
      }

      return (
        <div className="chat-interface__message-list">
          {messages.map((message, index) => {
            const isMostRecentAI = mostRecentAIMessage && message === mostRecentAIMessage;

            return (
              <MessageBubble
                key={index}
                message={message}
                type={message.role === 'user' ? 'sent' : 'received'}
                showNotSatisfiedButton={isMostRecentAI}
                onNotSatisfied={onNotSatisfied}
                disabled={isFeedbackModalOpen || isGeneratingImprovement}
              />
            );
          })}
          <div ref={messagesEndRef} />
        </div>
      );
    };

    // ChatInput - Input field with send button
    // AC #4: ChatInput component with onSubmit and isLoading props
    // Story 2.4: Added optional disable during improvement generation
    const ChatInput = ({ onSubmit, isLoading = false }) => {
      const { validationError, setValidationError, isGeneratingImprovement } = useAppContext();
      const [inputValue, setInputValue] = React.useState('');
      const inputRef = React.useRef(null);

      // Optimize handleChange with useCallback to prevent unnecessary re-renders
      const handleChange = React.useCallback((e) => {
        setInputValue(e.target.value);
        // Clear validation error when user starts typing
        if (validationError && e.target.value.trim()) {
          setValidationError(null);
        }
      }, [validationError, setValidationError]);

      // Optimize handleSubmit with useCallback
      const handleSubmit = React.useCallback((e) => {
        e.preventDefault();

        // Validation: Empty input
        if (!inputValue.trim()) {
          setValidationError({ message: 'Please enter a prompt', code: 'EMPTY_INPUT' });
          inputRef.current?.focus();
          return;
        }

        // Validation: Maximum length
        if (inputValue.length > MAX_PROMPT_LENGTH) {
          setValidationError({ message: 'Prompt is too long. Maximum 2000 characters.', code: 'MAX_LENGTH_EXCEEDED' });
          return;
        }

        const userPrompt = inputValue.trim();
        setInputValue(''); // Clear input (FR6)

        // Call parent's onSubmit handler with the prompt
        onSubmit(userPrompt);
      }, [inputValue, setValidationError, onSubmit]);

      // Story 2.4: Disable input during chat loading OR improvement generation
      const isDisabled = isLoading || isGeneratingImprovement;

      return (
        <>
          <form className="chat-interface__input-form" onSubmit={handleSubmit}>
            <input
              ref={inputRef}
              className="chat-interface__input-field"
              type="text"
              value={inputValue}
              onChange={handleChange}
              placeholder={isGeneratingImprovement ? "Please wait while we generate your improvement..." : "Enter your prompt..."}
              disabled={isDisabled}
            />
            <Button
              onClick={handleSubmit}
              disabled={isDisabled || !inputValue.trim()}
            >
              {isLoading ? 'Sending...' : 'Send'}
            </Button>
          </form>
          {validationError && <ValidationError error={validationError} />}
        </>
      );
    };

    // LAYOUT COMPONENT (defined last)

    // ChatInterface - Main chat layout with message list and input
    // AC #5: ChatInterface component using useAppContext
    // Story 2.1: Added logic to find most recent AI message and handle "Not Satisfied" button
    // Story 2.4: Added LoadingIndicator for feedback processing state
    const ChatInterface = () => {
      const { chatHistory, isChatLoading, chatError, addMessage, setChatError, setIsChatLoading, setValidationError, isFeedbackModalOpen, setIsFeedbackModalOpen, setRecentFeedback, isGeneratingImprovement } = useAppContext();
      const [pendingPrompt, setPendingPrompt] = React.useState(null);

      // Story 2.1: Find most recent AI response for "Not Satisfied" button
      const getMostRecentAIMessage = React.useCallback(() => {
        const aiMessages = chatHistory.filter(msg => msg.role === 'assistant');
        return aiMessages.length > 0 ? aiMessages[aiMessages.length - 1] : null;
      }, [chatHistory]);

      const mostRecentAIMessage = getMostRecentAIMessage();

      // Story 2.1: Handle "Not Satisfied" button click
      // Opens feedback modal - Story 2.3 will capture feedback data on submit
      const handleNotSatisfied = React.useCallback(() => {
        setIsFeedbackModalOpen(true);
      }, [setIsFeedbackModalOpen]);

      // API integration submit handler - Story 1.4 implementation with retry support
      // Optimized with useCallback to prevent unnecessary re-renders
      const handleSubmit = React.useCallback(async (userPrompt) => {
        try {
          // Store prompt for potential retry
          setPendingPrompt(userPrompt);

          // Add user message to chat history
          addMessage({ role: 'user', content: userPrompt });

          // Clear validation and error on new submission
          setValidationError(null);
          setChatError(null);

          // Set loading state
          setIsChatLoading(true);

          // Call API
          const aiResponse = await callChatAPI(userPrompt);

          // Add AI response to chat history
          addMessage({ role: 'assistant', content: aiResponse });

          // Clear error on success
          setChatError(null);
          setPendingPrompt(null);
        } catch (error) {
          // Set error object for display
          setChatError(error);
          console.error('API call failed:', error.message);
        } finally {
          // Always clear loading state
          setIsChatLoading(false);
        }
      }, [addMessage, setChatError, setIsChatLoading, setValidationError]);

      // Optimize handleRetry with useCallback
      const handleRetry = React.useCallback(async () => {
        if (pendingPrompt) {
          setChatError(null); // Clear error before retry
          await handleSubmit(pendingPrompt);
        }
      }, [pendingPrompt, setChatError, handleSubmit]);

      return (
        <div className="chat-interface">
          <MessageList
            messages={chatHistory}
            mostRecentAIMessage={mostRecentAIMessage}
            onNotSatisfied={handleNotSatisfied}
            isFeedbackModalOpen={isFeedbackModalOpen}
            isGeneratingImprovement={isGeneratingImprovement}
          />

          {/* Story 2.4: Loading Indicator - Shows when improvement is being generated */}
          {isGeneratingImprovement && (
            <LoadingIndicator message="Generating improvement..." />
          )}

          {chatError && <ErrorDisplay error={chatError} onRetry={handleRetry} />}
          <div className="chat-interface__input-container">
            <ChatInput onSubmit={handleSubmit} isLoading={isChatLoading} />
          </div>
        </div>
      );
    };

    // FeedbackModal - Layout component (Story 2.2)
    // Modal dialog for collecting user feedback about AI responses
    // Props: isOpen (boolean), onClose (callback), onSubmit (callback with feedbackText)
    // Architecture: feedbackText stored in LOCAL state (not context) - form data should be
    // ephemeral and component-scoped, not polluting global state
    // Memoized to prevent unnecessary re-renders when parent App re-renders
    const FeedbackModal = React.memo(({ isOpen, onClose, onSubmit }) => {
      const [feedbackText, setFeedbackText] = React.useState('');
      const [isSubmitting, setIsSubmitting] = React.useState(false);
      const textareaRef = React.useRef(null);

      // Define handleClose with useCallback to prevent ESC effect from re-running unnecessarily
      const handleClose = React.useCallback(() => {
        setFeedbackText(''); // Clear feedback text
        setIsSubmitting(false); // Reset submitting state
        onClose(); // Call parent callback
      }, [onClose]);

      // Auto-focus textarea when modal opens
      // Note: No cleanup needed - focus is a one-time side effect
      React.useEffect(() => {
        if (isOpen && textareaRef.current) {
          textareaRef.current.focus();
        }
      }, [isOpen]);

      // ESC key handler - now safe with handleClose memoized
      React.useEffect(() => {
        const handleEsc = (event) => {
          if (event.key === 'Escape' && isOpen) {
            handleClose();
          }
        };

        document.addEventListener('keydown', handleEsc);
        return () => document.removeEventListener('keydown', handleEsc);
      }, [isOpen, handleClose]);

      const handleSubmit = () => {
        // Guard against double submission
        if (isSubmitting) return;

        // Validate feedback text
        if (!feedbackText.trim()) {
          return; // Button should be disabled, but defensive check
        }

        // Set submitting state
        setIsSubmitting(true);

        // Call parent submit handler
        onSubmit(feedbackText);

        // Note: Modal will close via parent's setIsFeedbackModalOpen(false)
        // State will be reset when modal closes via handleClose
      };

      const handleOverlayClick = (event) => {
        // Close only if overlay is clicked, not modal container
        if (event.target === event.currentTarget) {
          handleClose();
        }
      };

      if (!isOpen) return null;

      return (
        <div className="feedback-modal__overlay" onClick={handleOverlayClick}>
          <div
            className="feedback-modal"
            role="dialog"
            aria-labelledby="feedback-modal-title"
            aria-describedby="feedback-modal-description"
          >
            {/* Header */}
            <div className="feedback-modal__header">
              <h2 id="feedback-modal-title">Let's improve this result</h2>
            </div>

            {/* Body */}
            <div className="feedback-modal__body">
              <textarea
                ref={textareaRef}
                id="feedback-modal-description"
                className="feedback-modal__textarea"
                placeholder="What didn't you like about this result?"
                value={feedbackText}
                onChange={(e) => setFeedbackText(e.target.value)}
                rows={3}
                maxLength={500}
                aria-label="Feedback input"
                disabled={isSubmitting}
              />
              <p
                className={`feedback-modal__char-counter ${
                  feedbackText.length > 450 ? 'feedback-modal__char-counter--danger' :
                  feedbackText.length > 400 ? 'feedback-modal__char-counter--warning' : ''
                }`}
              >
                {feedbackText.length} / 500 characters
              </p>
            </div>

            {/* Footer */}
            <div className="feedback-modal__footer">
              <button
                className="feedback-modal__cancel-button"
                onClick={handleClose}
                disabled={isSubmitting}
              >
                Cancel
              </button>
              <button
                className="feedback-modal__submit-button"
                onClick={handleSubmit}
                disabled={!feedbackText.trim() || isSubmitting}
              >
                {isSubmitting ? 'Generating...' : 'Generate Improved Prompt'}
              </button>
            </div>
          </div>
        </div>
      );
    });

    // ============================================================
    // SECTION 5: CONTEXT PROVIDER
    // ============================================================

    // AppContext - Global application state
    const AppContext = React.createContext(null);

    // AC #2: AppProvider component with useState hooks and context value
    const AppProvider = ({ children }) => {
      // AC #1: Complete state structure
      // Chat state
      const [chatHistory, setChatHistory] = React.useState([]);
      const [isChatLoading, setIsChatLoading] = React.useState(false);
      const [chatError, setChatError] = React.useState(null);

      // Story 1.5: Validation state
      const [validationError, setValidationError] = React.useState(null);

      // Modal states
      const [isFeedbackModalOpen, setIsFeedbackModalOpen] = React.useState(false);
      const [isComparisonModalOpen, setIsComparisonModalOpen] = React.useState(false);
      const [comparisonData, setComparisonData] = React.useState(null);

      // Improvement state
      const [isGeneratingImprovement, setIsGeneratingImprovement] = React.useState(false);
      const [improvementError, setImprovementError] = React.useState(null);

      // Feedback context
      const [recentFeedback, setRecentFeedback] = React.useState(null);

      // AC #3: Immutable state update helpers
      const addMessage = (message) => {
        setChatHistory(prev => [...prev, message]);
      };

      const clearChat = () => {
        setChatHistory([]);
        setChatError(null);
        setRecentFeedback(null);
        setComparisonData(null);
      };

      // Memoize context value to prevent unnecessary re-renders
      const value = React.useMemo(() => ({
        // State values
        chatHistory,
        isChatLoading,
        chatError,
        validationError,
        isFeedbackModalOpen,
        isComparisonModalOpen,
        comparisonData,
        isGeneratingImprovement,
        improvementError,
        recentFeedback,
        // State updaters
        setChatHistory,
        setIsChatLoading,
        setChatError,
        setValidationError,
        setIsFeedbackModalOpen,
        setIsComparisonModalOpen,
        setComparisonData,
        setIsGeneratingImprovement,
        setImprovementError,
        setRecentFeedback,
        // Helper functions
        addMessage,
        clearChat
      }), [
        chatHistory,
        isChatLoading,
        chatError,
        validationError,
        isFeedbackModalOpen,
        isComparisonModalOpen,
        comparisonData,
        isGeneratingImprovement,
        improvementError,
        recentFeedback
      ]);

      return (
        <AppContext.Provider value={value}>
          {children}
        </AppContext.Provider>
      );
    };

    // ============================================================
    // SECTION 6: MAIN APP COMPONENT
    // ============================================================
    const App = () => {
      const {
        isFeedbackModalOpen,
        setIsFeedbackModalOpen,
        chatHistory,
        setRecentFeedback,
        setIsGeneratingImprovement,
        setImprovementError
      } = useAppContext();

      const handleFeedbackClose = () => {
        setIsFeedbackModalOpen(false);
      };

      const handleFeedbackSubmit = (feedbackText) => {
        // Extract most recent messages from chat history
        // Find last user message
        const userMessages = chatHistory.filter(msg => msg.role === 'user');
        const lastUserMessage = userMessages[userMessages.length - 1];

        // Find last assistant message
        const assistantMessages = chatHistory.filter(msg => msg.role === 'assistant');
        const lastAssistantMessage = assistantMessages[assistantMessages.length - 1];

        // Edge case: No messages (shouldn't happen, but defensive)
        if (!lastUserMessage || !lastAssistantMessage) {
          console.error('No messages found in chat history');
          return;
        }

        // Create feedback object
        const feedback = {
          userPrompt: lastUserMessage.content,
          aiResponse: lastAssistantMessage.content,
          feedbackText: feedbackText,
          timestamp: Date.now()
        };

        // Store feedback in context
        setRecentFeedback(feedback);

        // Clear any previous improvement errors
        setImprovementError(null);

        // Trigger improvement generation state (Epic 3 will implement actual API call)
        setIsGeneratingImprovement(true);

        // Close feedback modal
        setIsFeedbackModalOpen(false);

        // TODO: Epic 3 will implement the actual improvement API call
        // Temporary: Reset isGeneratingImprovement after 2 seconds for testing
        setTimeout(() => {
          setIsGeneratingImprovement(false);
        }, 2000);
      };

      return (
        <div className="app-container">
          <ChatInterface />

          {/* Feedback Modal */}
          <FeedbackModal
            isOpen={isFeedbackModalOpen}
            onClose={handleFeedbackClose}
            onSubmit={handleFeedbackSubmit}
          />
        </div>
      );
    };

    // ============================================================
    // SECTION 7: RENDER
    // ============================================================
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      <AppProvider>
        <ErrorBoundary>
          <App />
        </ErrorBoundary>
      </AppProvider>
    );
  </script>
</body>
</html>
