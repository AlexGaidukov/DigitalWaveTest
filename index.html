<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DigitalWaveTest</title>

  <!-- React 18.x CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Babel Standalone -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    /* CSS Custom Properties */
    :root {
      --color-primary: #0066cc;
      --color-background: #f5f5f5;
      --color-text: #333333;
      --spacing-unit: 8px;
      --border-radius: 4px;
    }

    /* Global Reset */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    /* Body Styles */
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background-color: var(--color-background);
      color: var(--color-text);
      line-height: 1.6;
      min-width: 1024px;
    }

    /* App Container */
    .app-container {
      padding: calc(var(--spacing-unit) * 4);
      text-align: center;
    }

    .app-container__title {
      color: var(--color-primary);
    }

    /* Error Boundary */
    .error-boundary {
      padding: calc(var(--spacing-unit) * 4);
      text-align: center;
      background-color: #fee;
      border: 1px solid #c00;
      border-radius: var(--border-radius);
      margin: calc(var(--spacing-unit) * 2);
    }

    .error-boundary__title {
      color: #c00;
      margin-bottom: var(--spacing-unit);
    }

    .error-boundary__message {
      color: var(--color-text);
    }

    .error-boundary__button {
      margin-top: calc(var(--spacing-unit) * 2);
      padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
      background-color: var(--color-primary);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
    }

    .error-boundary__button:hover {
      opacity: 0.9;
    }

    /* Chat Interface Component */
    .chat-interface {
      display: flex;
      flex-direction: column;
      height: calc(100vh - calc(var(--spacing-unit) * 8));
      max-width: 900px;
      margin: 0 auto;
      background-color: #ffffff;
      border-radius: var(--border-radius);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    /* Message List Component */
    .chat-interface__message-list {
      flex: 1;
      overflow-y: auto;
      padding: calc(var(--spacing-unit) * 3);
      display: flex;
      flex-direction: column;
      gap: calc(var(--spacing-unit) * 2);
    }

    .chat-interface__empty-state {
      text-align: center;
      color: #999;
      padding: calc(var(--spacing-unit) * 8) calc(var(--spacing-unit) * 4);
      font-size: 16px;
    }

    /* Message Bubble Component */
    .chat-interface__message {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      margin-bottom: calc(var(--spacing-unit) * 2);
    }

    .chat-interface__message--sent {
      align-items: flex-end;
    }

    .chat-interface__message--received {
      align-items: flex-start;
    }

    .chat-interface__message-content {
      max-width: 70%;
      padding: calc(var(--spacing-unit) * 2) calc(var(--spacing-unit) * 3);
      border-radius: calc(var(--spacing-unit) * 2);
      word-wrap: break-word;
      line-height: 1.5;
    }

    .chat-interface__message--sent .chat-interface__message-content {
      background-color: var(--color-primary);
      color: #ffffff;
    }

    .chat-interface__message--received .chat-interface__message-content {
      background-color: #f0f0f0;
      color: var(--color-text);
    }

    /* Input Container */
    .chat-interface__input-container {
      padding: calc(var(--spacing-unit) * 3);
      border-top: 1px solid #e0e0e0;
      background-color: #ffffff;
    }

    /* Chat Input Form */
    .chat-interface__input-form {
      display: flex;
      gap: calc(var(--spacing-unit) * 2);
      align-items: center;
    }

    /* Input Field */
    .chat-interface__input-field {
      flex: 1;
      padding: calc(var(--spacing-unit) * 2) calc(var(--spacing-unit) * 3);
      border: 2px solid #e0e0e0;
      border-radius: var(--border-radius);
      font-size: 16px;
      font-family: inherit;
      outline: none;
      transition: border-color 0.2s ease;
    }

    .chat-interface__input-field:focus {
      border-color: var(--color-primary);
    }

    .chat-interface__input-field:disabled {
      background-color: #f5f5f5;
      cursor: not-allowed;
    }

    /* Button Component */
    .chat-interface__button {
      padding: calc(var(--spacing-unit) * 2) calc(var(--spacing-unit) * 4);
      background-color: var(--color-primary);
      color: #ffffff;
      border: none;
      border-radius: var(--border-radius);
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: opacity 0.2s ease;
      white-space: nowrap;
    }

    .chat-interface__button:hover:not(:disabled) {
      opacity: 0.9;
    }

    .chat-interface__button--disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .chat-interface__button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Validation Error (Story 1.5) */
    .chat-interface__validation-error {
      padding: calc(var(--spacing-unit) * 1) calc(var(--spacing-unit) * 2);
      margin-top: calc(var(--spacing-unit) * 1);
      background-color: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: var(--border-radius);
    }

    .chat-interface__validation-message {
      color: #856404;
      font-size: 14px;
      margin: 0;
    }

    /* Error Display (Story 1.5) */
    .chat-interface__error-display {
      padding: calc(var(--spacing-unit) * 2) calc(var(--spacing-unit) * 3);
      margin-bottom: calc(var(--spacing-unit) * 2);
      background-color: #f8d7da;
      border: 1px solid #f5c6cb;
      border-radius: var(--border-radius);
      display: flex;
      align-items: center;
      gap: calc(var(--spacing-unit) * 2);
    }

    .chat-interface__error-message {
      color: #721c24;
      font-size: 14px;
      margin: 0;
      flex: 1;
    }

    .chat-interface__retry-button {
      padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
      background-color: var(--color-primary);
      color: #ffffff;
      border: none;
      border-radius: var(--border-radius);
      font-size: 14px;
      cursor: pointer;
      white-space: nowrap;
    }

    .chat-interface__retry-button:hover {
      opacity: 0.9;
    }

    /* Story 2.1: "Not Satisfied" button styling */
    .message-bubble__not-satisfied {
      margin-top: calc(var(--spacing-unit) * 1);
      padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 1.5);
      background-color: transparent;
      border: 1px solid var(--color-primary);
      color: var(--color-primary);
      border-radius: var(--border-radius);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.1s ease-in-out;
    }

    .message-bubble__not-satisfied:hover:not(:disabled) {
      background-color: var(--color-primary);
      color: #ffffff;
      opacity: 0.9;
    }

    /* Story 2.2: Feedback Modal Component styling */
    /* Modal Overlay - Semi-transparent backdrop */
    .feedback-modal__overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    /* Modal Container - Centered box */
    .feedback-modal {
      background-color: #ffffff;
      border-radius: calc(var(--border-radius) * 2);
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    }

    /* Modal Header */
    .feedback-modal__header {
      padding: calc(var(--spacing-unit) * 2);
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }

    .feedback-modal__header h2 {
      margin: 0;
      font-size: 24px;
      color: var(--color-text);
      font-weight: 600;
    }

    /* Modal Body */
    .feedback-modal__body {
      padding: calc(var(--spacing-unit) * 2);
    }

    /* Textarea Input */
    .feedback-modal__textarea {
      width: 100%;
      min-height: 100px;
      padding: calc(var(--spacing-unit) * 1);
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: var(--border-radius);
      font-size: 16px;
      font-family: inherit;
      resize: vertical;
      box-sizing: border-box;
    }

    .feedback-modal__textarea:focus {
      outline: 2px solid var(--color-primary);
      border-color: transparent;
    }

    /* Modal Footer */
    .feedback-modal__footer {
      padding: calc(var(--spacing-unit) * 2);
      border-top: 1px solid rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: flex-end;
      gap: calc(var(--spacing-unit) * 1);
    }

    /* Cancel Button - Secondary style */
    .feedback-modal__cancel-button {
      padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 1.5);
      background-color: transparent;
      border: 1px solid var(--color-primary);
      color: var(--color-primary);
      border-radius: var(--border-radius);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.1s ease-in-out;
    }

    .feedback-modal__cancel-button:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    /* Submit Button - Primary style */
    .feedback-modal__submit-button {
      padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 1.5);
      background-color: var(--color-primary);
      border: none;
      color: #ffffff;
      border-radius: var(--border-radius);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.1s ease-in-out;
    }

    .feedback-modal__submit-button:hover:not(:disabled) {
      opacity: 0.9;
    }

    .feedback-modal__submit-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Character Counter */
    .feedback-modal__char-counter {
      margin-top: calc(var(--spacing-unit) * 0.5);
      font-size: 12px;
      color: #666;
      text-align: right;
    }

    .feedback-modal__char-counter--warning {
      color: #f57c00;
    }

    .feedback-modal__char-counter--danger {
      color: #d32f2f;
    }

    /* Story 2.4: Loading Indicator */
    .chat-interface__loading-indicator {
      display: flex;
      align-items: center;
      gap: var(--spacing-unit);
      padding: var(--spacing-unit);
      margin: var(--spacing-unit) 0;
      background-color: rgba(0, 0, 0, 0.02);
      border-radius: var(--border-radius);
      animation: fadeIn 200ms ease-in;
    }

    .chat-interface__loading-spinner {
      width: 16px;
      height: 16px;
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-top-color: var(--color-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .chat-interface__loading-text {
      color: rgba(0, 0, 0, 0.6);
      font-style: italic;
      font-size: 14px;
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }

    /* Not Satisfied button disabled state */
    .message-bubble__not-satisfied:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background-color: rgba(0, 0, 0, 0.1);
    }

    /* Story 4.1: Comparison Modal Component styling */
    /* Modal Overlay - Semi-transparent backdrop */
    .comparison-modal__overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.2s ease-out;
    }

    /* Modal Container - Centered box */
    .comparison-modal {
      background-color: #ffffff;
      border-radius: calc(var(--border-radius) * 2);
      max-width: 900px;
      max-height: 80vh;
      width: 90%;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
      animation: slideUp 0.2s ease-out;
      overflow: hidden;
    }

    /* Modal Header */
    .comparison-modal__header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: calc(var(--spacing-unit) * 1.5);
      border-bottom: 1px solid #e0e0e0;
    }

    .comparison-modal__title {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 0;
      color: var(--color-text);
    }

    .comparison-modal__close-button {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 8px;
      color: #666;
      transition: color 0.2s;
    }

    .comparison-modal__close-button:hover {
      color: #333;
    }

    /* Modal Body - Two Column Layout */
    .comparison-modal__body {
      display: flex;
      gap: calc(var(--spacing-unit) * 2);
      padding: calc(var(--spacing-unit) * 1.5);
      overflow-y: auto;
      flex: 1;
    }

    /* Columns */
    .comparison-modal__column {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0; /* Prevents flex items from overflowing */
    }

    .comparison-modal__column--original {
      /* Left column styling */
    }

    .comparison-modal__column--improved {
      /* Right column styling */
    }

    /* Column Headers */
    .comparison-modal__column-header {
      font-size: 0.875rem;
      font-weight: 600;
      margin-bottom: var(--spacing-unit);
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .comparison-modal__column-header--improved {
      color: var(--color-primary);
    }

    /* Column Content */
    .comparison-modal__content {
      flex: 1;
      font-size: 1rem;
      line-height: 1.6;
      white-space: pre-wrap; /* Preserve line breaks */
      word-wrap: break-word; /* Wrap long words */
      overflow-y: auto;
    }

    /* Modal Footer */
    .comparison-modal__footer {
      display: flex;
      justify-content: center;
      padding: calc(var(--spacing-unit) * 1.5);
      border-top: 1px solid #e0e0e0;
    }

    .comparison-modal__use-button {
      background-color: var(--color-primary);
      color: #ffffff;
      border: none;
      padding: 12px 32px;
      font-size: 1rem;
      font-weight: 600;
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
    }

    .comparison-modal__use-button:hover {
      background-color: #0052a3;
      transform: translateY(-1px);
    }

    .comparison-modal__use-button:active {
      transform: translateY(0);
    }

    /* Animations */
    @keyframes slideUp {
      from {
        transform: translateY(20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    /* Scrollbar styling for modal content */
    .comparison-modal__content::-webkit-scrollbar {
      width: 8px;
    }

    .comparison-modal__content::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }

    .comparison-modal__content::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }

    .comparison-modal__content::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    /* Story 4.2: HighlightedText Component Styles */
    .highlighted-text {
      display: inline;
    }

    .highlighted-text__segment {
      padding: 2px 4px;
      border-radius: 4px;
      transition: background-color 0.2s ease, transform 0.1s ease;
    }

    /* Addition highlight - Green/yellow background (subtle) */
    .highlighted-text__segment--addition {
      background-color: #d4edda; /* Subtle green */
      color: #155724;
    }

    .highlighted-text__segment--addition:hover {
      background-color: #c3e6cb; /* Slightly darker on hover */
      transform: scale(1.02);
    }

    /* Change highlight - Orange/amber background */
    .highlighted-text__segment--change {
      background-color: #fff3cd; /* Subtle orange/amber */
      color: #856404;
    }

    .highlighted-text__segment--change:hover {
      background-color: #ffeeba;
      transform: scale(1.02);
    }

    /* Enhancement highlight - Blue/purple background */
    .highlighted-text__segment--enhancement {
      background-color: #d1ecf1; /* Subtle blue */
      color: #0c5460;
    }

    .highlighted-text__segment--enhancement:hover {
      background-color: #bee5eb;
      transform: scale(1.02);
    }

    /* Story 4.3: MappingBadge Component Styles */
    .mapping-badge {
      display: inline-block;
      width: 24px;
      height: 24px;
      line-height: 24px;
      text-align: center;
      border-radius: 50%;
      background-color: #e9ecef; /* Muted gray */
      color: #495057;
      font-size: 14px;
      font-weight: 500;
      margin-left: 8px;
      margin-right: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
    }

    .mapping-badge:hover,
    .mapping-badge--active {
      background-color: #adb5bd; /* Darker gray on hover */
      transform: scale(1.1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .mapping-badge:focus {
      outline: 2px solid #007bff;
      outline-offset: 2px;
    }

    /* Story 4.3: HighlightedSentences Component Styles */
    .highlighted-sentences {
      display: block;
      white-space: pre-wrap; /* Preserve line breaks */
      line-height: 1.6;
    }

    .original-sentence {
      display: inline;
    }

    .original-sentence--highlighted {
      background-color: #f8f9fa; /* Very subtle background */
      border-bottom: 2px solid #dee2e6; /* Subtle underline */
      padding: 2px 4px;
      border-radius: 3px;
    }

    .original-sentence--highlighted:hover {
      background-color: #e9ecef;
      border-bottom-color: #adb5bd;
    }

    /* Story 4.3: ImprovedPromptWithBadges Styles */
    .improved-prompt-with-badges {
      display: inline;
    }

    /* Story 4.4: Tooltip Component Styles */
    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip__content {
      position: fixed; /* Fixed positioning to avoid clipping by modal overflow */
      top: 50%; /* Center vertically - will be positioned by JS */
      left: 50%; /* Center horizontally - will be positioned by JS */
      transform: translate(-50%, -50%); /* Center on viewport */
      max-width: 500px; /* Much wider for better readability */
      min-width: 300px; /* Minimum width for consistent appearance */
      padding: 16px 20px; /* More padding for better readability */
      background-color: rgba(44, 62, 80, 0.85); /* Dark background with 85% opacity */
      color: #f8f9fa; /* High contrast text */
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3); /* Stronger shadow for floating effect */
      font-size: 0.9375rem; /* Slightly larger font (15px) */
      line-height: 1.6; /* Better line spacing */
      text-align: left; /* Left align for better readability */
      white-space: pre-wrap; /* Preserve newlines and wrap text */
      word-wrap: break-word; /* Break long words */
      z-index: 9999; /* Very high z-index to be above everything including modal */
      opacity: 0;
      animation: tooltipFadeIn 0.2s ease-out forwards;
      backdrop-filter: blur(10px); /* Blur background behind tooltip */
      -webkit-backdrop-filter: blur(10px); /* Safari support */
    }

    .tooltip__arrow {
      display: none; /* Hide arrow for centered modal-style tooltip */
    }

    @keyframes tooltipFadeIn {
      from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* Focus indicator for keyboard accessibility */
    .tooltip > span[tabindex="0"]:focus {
      outline: 2px solid #4a90e2;
      outline-offset: 2px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    // ============================================================
    // SECTION 1: CONSTANTS & CONFIGURATION
    // ============================================================

    // API Configuration
    const WORKER_URL = 'https://digitalwave-test-proxy.x-gs-x.workers.dev';
    const CHAT_SYSTEM_PROMPT = 
      `You are a helpful assistant. Respond to user prompts naturally.

      You can ONLY assist with product name generation based on the packaging options below. 
      If the user asks about anything else, politely decline and redirect them to select a 
      packaging option for name generation.

      ## Task
      You are testing a product name generation system. The user will select one of four 
      product packaging options below. Based on the packaging description, generate an 
      appropriate product name.

      ## Available Product Packaging Options

      **Option 1 - Condiment Packet:**
      A single-serve foil condiment packet containing ketchup. The packaging features a 
      patriotic red, white, and blue color scheme with a triangular flag-inspired graphic 
      containing stars. The design includes a charitable cause partnership badge and 
      ingredient information printed on the side. The overall aesthetic suggests 
      American-made, family-values branding.

      **Option 2 - Dairy Carton:**
      A gable-top cardboard milk carton with a blue plastic screw cap. The design uses a 
      blue and white color palette with stylized milk splash graphics. Features include a 
      "Natural" diagonal ribbon banner, a circular quality seal badge, and fresh dairy 
      imagery. The typography is clean and modern with rounded lettering.

      **Option 3 - Beverage Cans (Variety Pack):**
      A set of three aluminum soda cans marketed as a healthier alternative. Features 
      retro-style curved script typography as the main logo. Flavors shown: a dark red 
      cola-style variant, a pink cherry cola, and an orange root beer with a float 
      illustration. Each can displays health claims including prebiotics, vitamins, 
      minerals, low sugar content (5-6g), and NON-GMO certification.

      **Option 4 - Cheese Product:**
      Processed cheese slices in a blue plastic and cardboard package. Contains 12
      individually wrapped slices, 200g total weight. The packaging shows a burger
      photograph demonstrating product usage. Multilingual text appears in Arabic, English,
      and Spanish. The brand logo uses a simple, friendly rounded typeface in a dark blue
      oval.`;

    const IMPROVEMENT_SYSTEM_PROMPT = `You are a prompt engineering expert. Analyze the user's original prompt and restructure it using the Rules/Task/Examples framework.

Rules: Constraints and guidelines the AI should follow
Task: Clear, specific instruction of what to generate
Examples: Sample outputs showing desired style

Return JSON with:
- improvedPrompt: restructured version
- mapping: [{originalSentence, improvedSections: []}]
- explanations: [{section, tooltip}]`;

    const CHAT_TIMEOUT = 10000; // 10 seconds for chat API
    const IMPROVEMENT_TIMEOUT = 15000; // 15 seconds for improvement generation (NFR-P4)
    const MAX_PROMPT_LENGTH = 2000;

    // ============================================================
    // SECTION 2: UTILITY FUNCTIONS
    // ============================================================

    // parseMapping - Parse mapping data to generate badge numbers and relationships (Story 4.3)
    // Returns structured mapping data for rendering badges and highlights
    // Returns: { badges: { badgeNumber: { originalSentence, improvedSections } }, sentenceMappings: [] }
    const parseMapping = (mapping, originalPrompt) => {
      const startTime = performance.now();

      if (!mapping || !Array.isArray(mapping) || mapping.length === 0) {
        return { badges: {}, sentenceMappings: [] };
      }

      // Generate badge numbers for each mapping group
      const badges = {};
      const sentenceMappings = [];

      mapping.forEach((mapItem, index) => {
        const badgeNumber = index + 1; // 1, 2, 3...

        badges[badgeNumber] = {
          originalSentence: mapItem.originalSentence,
          improvedSections: mapItem.improvedSections || []
        };

        sentenceMappings.push({
          badgeNumber: badgeNumber,
          originalSentence: mapItem.originalSentence,
          improvedSections: mapItem.improvedSections || []
        });
      });

      const endTime = performance.now();
      const parsingTime = endTime - startTime;

      // Log performance in development (verify <200ms target per NFR-P6)
      if (parsingTime > 50) {
        console.warn(`parseMapping took ${parsingTime.toFixed(2)}ms (target: <200ms)`);
      }

      return { badges, sentenceMappings };
    };

    // parseSentences - Parse original prompt into sentences (period-delimited) (Story 4.3)
    // Returns array of sentence objects with mapping badges
    // Returns: [{ text, badgeNumber }]
    // Story 4.3 Performance: Measures parsing time to verify <200ms target (NFR-P6)
    const parseSentences = (originalPrompt, sentenceMappings) => {
      const startTime = performance.now();

      if (!originalPrompt || typeof originalPrompt !== 'string') {
        return [];
      }

      // Split by period delimiter
      const sentences = originalPrompt.split('.').filter(s => s.trim().length > 0);

      const result = sentences.map(sentence => {
        const trimmedSentence = sentence.trim();

        // Find if this sentence has a mapping
        const mapping = sentenceMappings.find(m =>
          m.originalSentence.includes(trimmedSentence) ||
          trimmedSentence.includes(m.originalSentence)
        );

        return {
          text: trimmedSentence + '.', // Add period back
          badgeNumber: mapping ? mapping.badgeNumber : null
        };
      });

      const endTime = performance.now();
      const parsingTime = endTime - startTime;

      // Log performance in development (verify <200ms target per NFR-P6)
      if (parsingTime > 50) {
        console.warn(`parseSentences took ${parsingTime.toFixed(2)}ms (target: <200ms)`);
      }

      return result;
    };

    // parseImprovedPrompt - Parse improved prompt to extract R/T/E section highlights (Story 4.2)
    // Returns array of highlight objects for HighlightedText component
    // Each highlight object: { text, type, startIndex, endIndex }
    // Type can be: 'addition' (section headers), 'enhancement' (section content)
    // Story 4.2 Performance: Measures parsing time to verify <200ms target (NFR-P6)
    const parseImprovedPrompt = (improvedPrompt) => {
      const startTime = performance.now();

      if (!improvedPrompt || typeof improvedPrompt !== 'string') {
        return [];
      }

      const highlights = [];
      const sections = [
        { name: 'Rules', pattern: /Rules:/i },
        { name: 'Task', pattern: /Task:/i },
        { name: 'Examples', pattern: /Examples:/i }
      ];

      sections.forEach(section => {
        const match = improvedPrompt.match(section.pattern);
        if (match) {
          const startIndex = match.index;
          const endIndex = startIndex + match[0].length;

          // Highlight section header (e.g., "Rules:")
          highlights.push({
            text: match[0],
            type: 'addition',
            startIndex: startIndex,
            endIndex: endIndex
          });

          // Find the end of this section (start of next section or end of string)
          let sectionEnd = improvedPrompt.length;
          for (let nextSection of sections) {
            if (nextSection.name !== section.name) {
              const nextMatch = improvedPrompt.match(nextSection.pattern);
              if (nextMatch && nextMatch.index > endIndex) {
                sectionEnd = nextMatch.index;
                break;
              }
            }
          }

          // Highlight section content (after header until next section)
          if (sectionEnd > endIndex) {
            highlights.push({
              text: improvedPrompt.substring(endIndex, sectionEnd).trim(),
              type: 'enhancement',
              startIndex: endIndex,
              endIndex: sectionEnd
            });
          }
        }
      });

      const endTime = performance.now();
      const parsingTime = endTime - startTime;

      // Log performance in development (verify <200ms target per NFR-P6)
      if (parsingTime > 50) {
        console.warn(`parseImprovedPrompt took ${parsingTime.toFixed(2)}ms (target: <200ms)`);
      }

      return highlights;
    };

    // Error formatting utility - maps technical errors to user-friendly messages
    // Returns error object: { message, code }
    function formatError(error) {
      const errorMessages = {
        'API_TIMEOUT': 'The request took too long. Please try again.',
        'RATE_LIMIT_EXCEEDED': 'We\'re experiencing high demand. Please wait a moment and try again.',
        'INVALID_API_KEY': 'Service configuration error. Please contact support.',
        'NETWORK_ERROR': 'Connection issue. Please check your internet and try again.',
        'INVALID_RESPONSE': 'The AI returned an invalid response. Please try again.',
        'MISSING_FIELDS': 'Required information is missing. Please check your input and try again.',
        'UNKNOWN': 'Something went wrong. Please try again.'
      };

      const code = error.code || 'UNKNOWN';
      return {
        message: errorMessages[code] || errorMessages.UNKNOWN,
        code: code
      };
    }

    // Chat API integration - calls Cloudflare Worker proxy
    // Returns: Promise with AI response message
    // Throws: Formatted error object with code and message
    async function callChatAPI(userPrompt) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), CHAT_TIMEOUT);

        const response = await fetch(`${WORKER_URL}/api/chat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt: userPrompt }),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();

        if (!result.success) {
          throw new Error(result.error?.message || 'API call failed');
        }

        return result.data.message;
      } catch (error) {
        if (error.name === 'AbortError') {
          throw formatError({ code: 'API_TIMEOUT' });
        }
        throw formatError(error);
      }
    }

    // Improvement API integration - calls Cloudflare Worker proxy for prompt enhancement
    // Returns: Promise with { improvedPrompt, mapping, explanations }
    // Throws: Formatted error object with code and message
    async function generateImprovement(originalPrompt, userFeedback) {
      // Validate inputs
      if (!originalPrompt || typeof originalPrompt !== 'string' || originalPrompt.trim() === '') {
        throw formatError({ code: 'MISSING_FIELDS', message: 'Original prompt is required' });
      }

      if (!userFeedback || typeof userFeedback !== 'string' || userFeedback.trim() === '') {
        throw formatError({ code: 'MISSING_FIELDS', message: 'User feedback is required' });
      }

      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), IMPROVEMENT_TIMEOUT);

        const response = await fetch(`${WORKER_URL}/api/improve`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            originalPrompt: originalPrompt.trim(),
            userFeedback: userFeedback.trim()
          }),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();

        if (!result.success) {
          throw new Error(result.error?.message || 'Unknown error');
        }

        // Parse and validate response using parseImprovementResponse utility
        const improvementData = parseImprovementResponse(result);

        return improvementData;

      } catch (error) {
        // Format error for user-friendly display
        if (error.name === 'AbortError') {
          throw formatError({ code: 'API_TIMEOUT', message: 'Request timeout' });
        }

        if (error.message.includes('fetch') || error.message.includes('Network')) {
          throw formatError({ code: 'NETWORK_ERROR', message: error.message });
        }

        // Handle parseImprovementResponse errors
        if (error.message && error.message.includes('INVALID_RESPONSE')) {
          throw formatError({ code: 'INVALID_RESPONSE', message: error.message });
        }

        // Re-throw formatted errors
        throw error;
      }
    }

    // Response parsing utility - validates and parses improvement API response
    // Returns: { improvedPrompt, mapping, explanations }
    // Throws: Error with code 'INVALID_RESPONSE' if validation fails
    function parseImprovementResponse(apiResponse) {
      // Extract data from Worker response
      const { success, data, error } = apiResponse;

      // Check for Worker error
      if (!success || error) {
        throw new Error(error?.code || 'WORKER_UNAVAILABLE');
      }

      // Validate improvedPrompt
      if (!data.improvedPrompt || typeof data.improvedPrompt !== 'string') {
        throw new Error('INVALID_RESPONSE: Missing or invalid improvedPrompt');
      }

      if (data.improvedPrompt.trim().length === 0) {
        throw new Error('INVALID_RESPONSE: improvedPrompt is empty');
      }

      // Validate mapping
      if (!data.mapping || !Array.isArray(data.mapping)) {
        throw new Error('INVALID_RESPONSE: Missing or invalid mapping');
      }

      if (data.mapping.length === 0) {
        throw new Error('INVALID_RESPONSE: mapping array is empty');
      }

      // Validate each mapping item
      for (let i = 0; i < data.mapping.length; i++) {
        const item = data.mapping[i];

        if (!item.originalSentence || typeof item.originalSentence !== 'string') {
          throw new Error(`INVALID_RESPONSE: mapping[${i}] missing originalSentence`);
        }

        if (!item.improvedSections || !Array.isArray(item.improvedSections)) {
          throw new Error(`INVALID_RESPONSE: mapping[${i}] missing improvedSections`);
        }

        if (item.improvedSections.length === 0) {
          throw new Error(`INVALID_RESPONSE: mapping[${i}].improvedSections is empty`);
        }
      }

      // Validate explanations
      if (!data.explanations || !Array.isArray(data.explanations)) {
        throw new Error('INVALID_RESPONSE: Missing or invalid explanations');
      }

      if (data.explanations.length !== 3) {
        throw new Error('INVALID_RESPONSE: Expected exactly 3 explanations (Rules, Task, Examples)');
      }

      // Validate each explanation
      const requiredSections = ['Rules', 'Task', 'Examples'];
      const foundSections = [];

      for (let i = 0; i < data.explanations.length; i++) {
        const explanation = data.explanations[i];

        if (!explanation.section || typeof explanation.section !== 'string') {
          throw new Error(`INVALID_RESPONSE: explanations[${i}] missing section`);
        }

        if (!explanation.tooltip || typeof explanation.tooltip !== 'string') {
          throw new Error(`INVALID_RESPONSE: explanations[${i}] missing tooltip`);
        }

        if (explanation.tooltip.trim().length === 0) {
          throw new Error(`INVALID_RESPONSE: explanations[${i}].tooltip is empty`);
        }

        foundSections.push(explanation.section);
      }

      // Verify all required sections are present
      for (const required of requiredSections) {
        if (!foundSections.includes(required)) {
          throw new Error(`INVALID_RESPONSE: Missing explanation for ${required} section`);
        }
      }

      // Return validated data
      return {
        improvedPrompt: data.improvedPrompt,
        mapping: data.mapping,
        explanations: data.explanations
      };
    }

    // ============================================================
    // SECTION 3: CUSTOM HOOKS
    // ============================================================

    // AC #7: useAppContext custom hook with null safety check
    // Note: This hook references AppContext defined in SECTION 5.
    // This works due to JavaScript hoisting and is intentional pattern for hooks.
    const useAppContext = () => {
      const context = React.useContext(AppContext);
      if (context === null) {
        throw new Error('useAppContext must be used within an AppProvider');
      }
      return context;
    };

    // ============================================================
    // SECTION 4: REACT COMPONENTS
    // ============================================================

    // ErrorBoundary - Class component for catching React errors (must be first)
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
      }

      static getDerivedStateFromError(error) {
        return { hasError: true, error };
      }

      componentDidCatch(error, errorInfo) {
        console.error('ErrorBoundary caught an error:', error, errorInfo);
      }

      handleRetry = () => {
        this.setState({ hasError: false, error: null });
      };

      render() {
        if (this.state.hasError) {
          return (
            <div className="error-boundary">
              <h2 className="error-boundary__title">Something went wrong</h2>
              <p className="error-boundary__message">
                The application encountered an unexpected error.
              </p>
              <button className="error-boundary__button" onClick={this.handleRetry}>
                Try Again
              </button>
            </div>
          );
        }

        return this.props.children;
      }
    }

    // LEAF COMPONENTS (defined first)

    // Tooltip - Leaf component for displaying contextual help on hover/focus (Story 4.4)
    // Provides educational explanations for R/T/E framework sections
    // Props: children (React element) - Element that triggers the tooltip
    //        content (string or React node) - Tooltip content text
    // Accessibility: Keyboard accessible (focus/blur), screen reader support (aria-describedby), ESC key dismiss
    const Tooltip = ({ children, content }) => {
      const [isVisible, setIsVisible] = React.useState(false);
      const [timeoutId, setTimeoutId] = React.useState(null);
      const tooltipRef = React.useRef(null);

      // Show tooltip with small delay to prevent accidental triggers
      const handleMouseEnter = React.useCallback(() => {
        const id = setTimeout(() => {
          setIsVisible(true);
        }, 100); // 100ms delay
        setTimeoutId(id);
      }, []);

      // Hide tooltip immediately on mouse leave
      const handleMouseLeave = React.useCallback(() => {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        setIsVisible(false);
      }, [timeoutId]);

      // Handle keyboard accessibility
      const handleFocus = React.useCallback(() => {
        setIsVisible(true);
      }, []);

      const handleBlur = React.useCallback(() => {
        setIsVisible(false);
      }, []);

      // Handle ESC key to dismiss
      React.useEffect(() => {
        const handleEscape = (e) => {
          if (e.key === 'Escape' && isVisible) {
            setIsVisible(false);
          }
        };

        document.addEventListener('keydown', handleEscape);
        return () => {
          document.removeEventListener('keydown', handleEscape);
        };
      }, [isVisible]);

      // Clear timeout on unmount
      React.useEffect(() => {
        return () => {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
        };
      }, [timeoutId]);

      // Generate unique ID for aria-describedby
      const tooltipId = React.useId();
      const contentId = `tooltip-content-${tooltipId}`;

      return (
        <span
          className="tooltip"
          onMouseEnter={handleMouseEnter}
          onMouseLeave={handleMouseLeave}
          ref={tooltipRef}
        >
          <span
            onFocus={handleFocus}
            onBlur={handleBlur}
            tabIndex={0}
            aria-describedby={isVisible ? contentId : undefined}
          >
            {children}
          </span>

          {isVisible && (
            <div
              id={contentId}
              className="tooltip__content"
              role="tooltip"
              aria-live="polite"
            >
              <div className="tooltip__arrow"></div>
              {content}
            </div>
          )}
        </span>
      );
    };

    // MappingBadge - Leaf component for numbered mapping indicators (Story 4.3)
    // Shows relationship between original sentences and improved sections
    // Props: number (1, 2, 3) - Badge number, isActive (boolean) - Hover state, onClick (function) - Click handler
    // Accessibility: Keyboard accessible with tabIndex, aria-label, and Enter/Space key support
    const MappingBadge = ({ number, isActive = false, onClick }) => {
      // Convert number to circled unicode character: ①, ②, ③, etc.
      const circledNumbers = ['①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩'];
      const badgeText = circledNumbers[number - 1] || number;

      // Handle keyboard activation (Enter or Space)
      const handleKeyDown = (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          onClick(e);
        }
      };

      return (
        <span
          className={`mapping-badge ${isActive ? 'mapping-badge--active' : ''}`}
          onClick={onClick}
          onKeyDown={handleKeyDown}
          role="button"
          tabIndex={0}
          aria-label={`Mapping group ${number}`}
        >
          {badgeText}
        </span>
      );
    };

    // HighlightedText - Leaf component for rendering text with highlighted segments (Story 4.2)
    // Used to display improved prompt with color-coded R/T/E sections
    // Props: text (string) - The full text to render
    //        highlights (array) - Array of highlight objects: [{ text, type, startIndex, endIndex }]
    //        type: 'addition' | 'change' | 'enhancement'
    // Story 4.2 Performance: Measures rendering time to verify <200ms target (NFR-P6)
    const HighlightedText = ({ text, highlights }) => {
      const renderStartTime = React.useRef(null);

      // Measure render performance (using useEffect to capture after render)
      React.useEffect(() => {
        if (renderStartTime.current) {
          const renderEndTime = performance.now();
          const renderTime = renderEndTime - renderStartTime.current;

          // Log performance in development (verify <200ms target per NFR-P6)
          if (renderTime > 100) {
            console.warn(`HighlightedText render took ${renderTime.toFixed(2)}ms (target: <200ms)`);
          }
        }
      });

      // Start render timer
      renderStartTime.current = performance.now();

      // Guard clause - handle empty highlights gracefully
      if (!text || !highlights || highlights.length === 0) {
        return <span>{text}</span>;
      }

      // Sort highlights by startIndex to ensure correct order
      const sortedHighlights = [...highlights].sort((a, b) => a.startIndex - b.startIndex);

      // Build array of text segments (highlighted and non-highlighted)
      const segments = [];
      let lastIndex = 0;

      sortedHighlights.forEach(highlight => {
        // Add non-highlighted text before this highlight
        if (highlight.startIndex > lastIndex) {
          segments.push({
            text: text.substring(lastIndex, highlight.startIndex),
            type: null
          });
        }

        // Add highlighted segment
        segments.push({
          text: text.substring(highlight.startIndex, highlight.endIndex),
          type: highlight.type
        });

        lastIndex = highlight.endIndex;
      });

      // Add remaining text after last highlight
      if (lastIndex < text.length) {
        segments.push({
          text: text.substring(lastIndex),
          type: null
        });
      }

      return (
        <span className="highlighted-text">
          {segments.map((segment, index) => {
            if (segment.type) {
              return (
                <span
                  key={index}
                  className={`highlighted-text__segment highlighted-text__segment--${segment.type}`}
                >
                  {segment.text}
                </span>
              );
            }
            return <span key={index}>{segment.text}</span>;
          })}
        </span>
      );
    };

    // Button - Reusable button component with disabled state
    // AC #1: Button component with children, onClick, disabled, className props
    const Button = ({ children, onClick, disabled = false, className = '' }) => {
      const baseClass = 'chat-interface__button';
      const modifierClass = disabled ? 'chat-interface__button--disabled' : '';
      const combinedClassName = `${baseClass} ${modifierClass} ${className}`.trim().replace(/\s+/g, ' ');

      return (
        <button
          className={combinedClassName}
          onClick={onClick}
          disabled={disabled}
        >
          {children}
        </button>
      );
    };

    // LoadingIndicator - Display loading state with spinner (Story 2.4)
    // Leaf component for showing feedback processing state
    // Props: message (string) - Display text for loading indicator
    const LoadingIndicator = ({ message = "Generating improvement..." }) => {
      return (
        <div className="chat-interface__loading-indicator">
          <div className="chat-interface__loading-spinner"></div>
          <span className="chat-interface__loading-text">{message}</span>
        </div>
      );
    };

    // ValidationError - Display validation error messages (Story 1.5)
    // Leaf component for inline validation feedback
    // Memoized to prevent unnecessary re-renders
    const ValidationError = React.memo(({ error }) => {
      if (!error) return null;

      return (
        <div className="chat-interface__validation-error">
          <p className="chat-interface__validation-message">{error.message}</p>
        </div>
      );
    });

    // ErrorDisplay - Display API error messages with retry button (Story 1.5)
    // Leaf component for API error feedback
    // Memoized to prevent unnecessary re-renders
    const ErrorDisplay = React.memo(({ error, onRetry }) => {
      if (!error) return null;

      const isRetriable = ['API_TIMEOUT', 'NETWORK_ERROR', 'RATE_LIMIT_EXCEEDED'].includes(error.code);

      return (
        <div className="chat-interface__error-display">
          <p className="chat-interface__error-message">{error.message}</p>
          {isRetriable && onRetry && (
            <Button onClick={onRetry} className="chat-interface__retry-button">
              Try Again
            </Button>
          )}
        </div>
      );
    });

    // MessageBubble - Display individual chat message with role-based styling
    // AC #2: MessageBubble component with message object and type prop
    // Story 2.1: Added showNotSatisfiedButton, onNotSatisfied, disabled props for "Not Satisfied" button
    // Story 2.4: Button disabled when isGeneratingImprovement is true
    const MessageBubble = ({ message, type, showNotSatisfiedButton, onNotSatisfied, disabled }) => {
      const typeClass = type === 'sent' ? 'chat-interface__message--sent' : 'chat-interface__message--received';
      const isAI = message.role === 'assistant';

      return (
        <div className={`chat-interface__message ${typeClass}`}>
          <div className="chat-interface__message-content">
            {message.content}
          </div>
          {/* Story 2.1: Conditionally render "Not Satisfied" button on AI messages (outside content div for proper spacing) */}
          {/* Story 2.4: Button disabled during improvement generation */}
          {showNotSatisfiedButton && isAI && (
            <button
              className="message-bubble__not-satisfied"
              onClick={onNotSatisfied}
              disabled={disabled}
            >
              Not Satisfied
            </button>
          )}
        </div>
      );
    };

    // COMPOSITE COMPONENTS (defined after leaf components)

    // HighlightedSentences - Component for rendering original prompt with sentence highlights (Story 4.3)
    // Shows which original sentences were used in improved prompt with badge indicators
    // Props: originalPrompt (string) - The original prompt text
    //        sentenceMappings (array) - Mappings from parseMapping()
    const HighlightedSentences = ({ originalPrompt, sentenceMappings }) => {
      const sentences = parseSentences(originalPrompt, sentenceMappings);

      return (
        <div className="highlighted-sentences">
          {sentences.map((sentence, index) => {
            const hasMapping = sentence.badgeNumber !== null;

            return (
              <span
                key={index}
                className={`original-sentence ${hasMapping ? 'original-sentence--highlighted' : ''}`}
              >
                {sentence.text}
                {hasMapping && <MappingBadge number={sentence.badgeNumber} />}
                {' '}
              </span>
            );
          })}
        </div>
      );
    };

    // ImprovedPromptWithBadges - Renders improved prompt with highlights, mapping badges, and educational tooltips (Story 4.3, 4.4)
    // Combines HighlightedText (Story 4.2) with MappingBadge indicators (Story 4.3)
    // Story 4.4: Adds educational tooltips on section HEADERS explaining the R/T/E framework
    // Props: text (string) - Improved prompt text, highlights (array) - From parseImprovedPrompt()
    //        badges (object) - Badge mappings from parseMapping(), activeBadgeNumber (number) - Currently hovered badge
    //        onBadgeHover (function) - Handler for badge hover
    //        explanations (array) - Section explanations from comparisonData.explanations (Story 4.4)
    const ImprovedPromptWithBadges = ({ text, highlights, badges, activeBadgeNumber, onBadgeHover, explanations }) => {
      // Create a map of section → badge numbers for rendering badges next to section headers
      const sectionToBadges = React.useMemo(() => {
        const map = {};
        Object.entries(badges).forEach(([badgeNum, badgeData]) => {
          badgeData.improvedSections.forEach(section => {
            if (!map[section]) {
              map[section] = [];
            }
            map[section].push(parseInt(badgeNum));
          });
        });
        return map;
      }, [badges]);

      // Story 4.4: Helper function to get educational tooltip content for a section
      const getTooltipContent = React.useCallback((sectionName) => {
        if (!explanations || explanations.length === 0) {
          // Fallback to generic framework education tooltips
          const genericTooltips = {
            'Rules': "Rules establish constraints and guidelines that guide the AI's creative direction. They help the AI understand your brand voice, positioning, and requirements.",
            'Task': "A clear task definition tells the AI exactly what to generate. Be specific about the output you want (e.g., 'Generate 10 product names' vs. 'Generate names').",
            'Examples': "Examples anchor the AI's understanding of your desired style. Providing reference points helps the AI match your expectations."
          };
          return genericTooltips[sectionName] || "This section helps structure your prompt for better AI responses.";
        }

        // Find section-specific explanation from comparisonData.explanations
        const explanation = explanations.find(ex => ex.section === sectionName);
        if (explanation && explanation.tooltip) {
          return explanation.tooltip;
        }

        // Fallback to generic
        return `This ${sectionName.toLowerCase()} section helps structure your prompt for better AI responses.`;
      }, [explanations]);

      // Parse highlights and inject badges next to section headers
      const segmentsWithBadges = React.useMemo(() => {
        if (!highlights || highlights.length === 0) {
          return [{ text, type: null, badges: [], sectionName: null }];
        }

        const segments = [];
        let lastIndex = 0;

        highlights.forEach(highlight => {
          // Add non-highlighted text before this highlight
          if (highlight.startIndex > lastIndex) {
            segments.push({
              text: text.substring(lastIndex, highlight.startIndex),
              type: null,
              badges: [],
              sectionName: null
            });
          }

          // Check if this highlight is a section header (e.g., "Rules:", "Task:", "Examples:")
          const isSectionHeader = highlight.type === 'addition';
          const sectionName = isSectionHeader
            ? highlight.text.replace(':', '').trim()
            : null;

          // Get badge numbers for this section header
          const sectionBadges = isSectionHeader && sectionToBadges[sectionName]
            ? sectionToBadges[sectionName]
            : [];

          // Add highlighted segment with badges
          segments.push({
            text: text.substring(highlight.startIndex, highlight.endIndex),
            type: highlight.type,
            badges: sectionBadges,
            sectionName: sectionName
          });

          lastIndex = highlight.endIndex;
        });

        // Add remaining text after last highlight
        if (lastIndex < text.length) {
          segments.push({
            text: text.substring(lastIndex),
            type: null,
            badges: [],
            sectionName: null
          });
        }

        return segments;
      }, [text, highlights, sectionToBadges]);

      return (
        <span className="improved-prompt-with-badges">
          {segmentsWithBadges.map((segment, index) => {
            if (segment.type) {
              const segmentElement = (
                <span
                  key={index}
                  className={`highlighted-text__segment highlighted-text__segment--${segment.type}`}
                >
                  {segment.badges.map(badgeNum => (
                    <MappingBadge
                      key={badgeNum}
                      number={badgeNum}
                      isActive={activeBadgeNumber === badgeNum}
                      onClick={() => onBadgeHover(badgeNum)}
                    />
                  ))}
                  {segment.text}
                </span>
              );

              // Story 4.4: Add educational tooltip to section HEADERS (Rules:, Task:, Examples:)
              if (segment.sectionName && ['Rules', 'Task', 'Examples'].includes(segment.sectionName)) {
                return (
                  <Tooltip key={index} content={getTooltipContent(segment.sectionName)}>
                    {segmentElement}
                  </Tooltip>
                );
              }

              return segmentElement;
            }
            return <span key={index}>{segment.text}</span>;
          })}
        </span>
      );
    };

    // MessageList - Display list of chat messages with auto-scroll
    // AC #3: MessageList component with auto-scroll and empty state
    // Story 2.1: Added mostRecentAIMessage, onNotSatisfied, isFeedbackModalOpen props for "Not Satisfied" button
    // Story 2.4: Added isGeneratingImprovement to disable button during loading
    const MessageList = ({ messages, mostRecentAIMessage, onNotSatisfied, isFeedbackModalOpen, isGeneratingImprovement }) => {
      const messagesEndRef = React.useRef(null);

      // Auto-scroll to bottom when messages change
      React.useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages]);

      if (messages.length === 0) {
        return (
          <div className="chat-interface__message-list">
            <div className="chat-interface__empty-state">
              No messages yet. Start by entering a prompt.
            </div>
          </div>
        );
      }

      return (
        <div className="chat-interface__message-list">
          {messages.map((message, index) => {
            const isMostRecentAI = mostRecentAIMessage && message === mostRecentAIMessage;

            return (
              <MessageBubble
                key={index}
                message={message}
                type={message.role === 'user' ? 'sent' : 'received'}
                showNotSatisfiedButton={isMostRecentAI}
                onNotSatisfied={onNotSatisfied}
                disabled={isFeedbackModalOpen || isGeneratingImprovement}
              />
            );
          })}
          <div ref={messagesEndRef} />
        </div>
      );
    };

    // ChatInput - Input field with send button
    // AC #4: ChatInput component with onSubmit and isLoading props
    // Story 2.4: Added optional disable during improvement generation
    const ChatInput = ({ onSubmit, isLoading = false }) => {
      const { validationError, setValidationError, isGeneratingImprovement } = useAppContext();
      const [inputValue, setInputValue] = React.useState('');
      const inputRef = React.useRef(null);

      // Optimize handleChange with useCallback to prevent unnecessary re-renders
      const handleChange = React.useCallback((e) => {
        setInputValue(e.target.value);
        // Clear validation error when user starts typing
        if (validationError && e.target.value.trim()) {
          setValidationError(null);
        }
      }, [validationError, setValidationError]);

      // Optimize handleSubmit with useCallback
      const handleSubmit = React.useCallback((e) => {
        e.preventDefault();

        // Validation: Empty input
        if (!inputValue.trim()) {
          setValidationError({ message: 'Please enter a prompt', code: 'EMPTY_INPUT' });
          inputRef.current?.focus();
          return;
        }

        // Validation: Maximum length
        if (inputValue.length > MAX_PROMPT_LENGTH) {
          setValidationError({ message: 'Prompt is too long. Maximum 2000 characters.', code: 'MAX_LENGTH_EXCEEDED' });
          return;
        }

        const userPrompt = inputValue.trim();
        setInputValue(''); // Clear input (FR6)

        // Call parent's onSubmit handler with the prompt
        onSubmit(userPrompt);
      }, [inputValue, setValidationError, onSubmit]);

      // Story 2.4: Disable input during chat loading OR improvement generation
      const isDisabled = isLoading || isGeneratingImprovement;

      return (
        <>
          <form className="chat-interface__input-form" onSubmit={handleSubmit}>
            <input
              ref={inputRef}
              className="chat-interface__input-field"
              type="text"
              value={inputValue}
              onChange={handleChange}
              placeholder={isGeneratingImprovement ? "Please wait while we generate your improvement..." : "Enter your prompt..."}
              disabled={isDisabled}
            />
            <Button
              onClick={handleSubmit}
              disabled={isDisabled || !inputValue.trim()}
            >
              {isLoading ? 'Sending...' : 'Send'}
            </Button>
          </form>
          {validationError && <ValidationError error={validationError} />}
        </>
      );
    };

    // LAYOUT COMPONENT (defined last)

    // ChatInterface - Main chat layout with message list and input
    // AC #5: ChatInterface component using useAppContext
    // Story 2.1: Added logic to find most recent AI message and handle "Not Satisfied" button
    // Story 2.4: Added LoadingIndicator for feedback processing state
    const ChatInterface = () => {
      const { chatHistory, isChatLoading, chatError, addMessage, setChatError, setIsChatLoading, setValidationError, isFeedbackModalOpen, setIsFeedbackModalOpen, setRecentFeedback, isGeneratingImprovement } = useAppContext();
      const [pendingPrompt, setPendingPrompt] = React.useState(null);

      // Story 2.1: Find most recent AI response for "Not Satisfied" button
      const getMostRecentAIMessage = React.useCallback(() => {
        const aiMessages = chatHistory.filter(msg => msg.role === 'assistant');
        return aiMessages.length > 0 ? aiMessages[aiMessages.length - 1] : null;
      }, [chatHistory]);

      const mostRecentAIMessage = getMostRecentAIMessage();

      // Story 2.1: Handle "Not Satisfied" button click
      // Opens feedback modal - Story 2.3 will capture feedback data on submit
      const handleNotSatisfied = React.useCallback(() => {
        setIsFeedbackModalOpen(true);
      }, [setIsFeedbackModalOpen]);

      // API integration submit handler - Story 1.4 implementation with retry support
      // Optimized with useCallback to prevent unnecessary re-renders
      const handleSubmit = React.useCallback(async (userPrompt) => {
        try {
          // Store prompt for potential retry
          setPendingPrompt(userPrompt);

          // Add user message to chat history
          addMessage({ role: 'user', content: userPrompt });

          // Clear validation and error on new submission
          setValidationError(null);
          setChatError(null);

          // Set loading state
          setIsChatLoading(true);

          // Call API
          const aiResponse = await callChatAPI(userPrompt);

          // Add AI response to chat history
          addMessage({ role: 'assistant', content: aiResponse });

          // Clear error on success
          setChatError(null);
          setPendingPrompt(null);
        } catch (error) {
          // Set error object for display
          setChatError(error);
          console.error('API call failed:', error.message);
        } finally {
          // Always clear loading state
          setIsChatLoading(false);
        }
      }, [addMessage, setChatError, setIsChatLoading, setValidationError]);

      // Optimize handleRetry with useCallback
      const handleRetry = React.useCallback(async () => {
        if (pendingPrompt) {
          setChatError(null); // Clear error before retry
          await handleSubmit(pendingPrompt);
        }
      }, [pendingPrompt, setChatError, handleSubmit]);

      return (
        <div className="chat-interface">
          <MessageList
            messages={chatHistory}
            mostRecentAIMessage={mostRecentAIMessage}
            onNotSatisfied={handleNotSatisfied}
            isFeedbackModalOpen={isFeedbackModalOpen}
            isGeneratingImprovement={isGeneratingImprovement}
          />

          {/* Story 2.4: Loading Indicator - Shows when improvement is being generated */}
          {isGeneratingImprovement && (
            <LoadingIndicator message="Generating improvement..." />
          )}

          {chatError && <ErrorDisplay error={chatError} onRetry={handleRetry} />}
          <div className="chat-interface__input-container">
            <ChatInput onSubmit={handleSubmit} isLoading={isChatLoading} />
          </div>
        </div>
      );
    };

    // FeedbackModal - Layout component (Story 2.2)
    // Modal dialog for collecting user feedback about AI responses
    // Props: isOpen (boolean), onClose (callback), onSubmit (callback with feedbackText)
    // Architecture: feedbackText stored in LOCAL state (not context) - form data should be
    // ephemeral and component-scoped, not polluting global state
    // Memoized to prevent unnecessary re-renders when parent App re-renders
    const FeedbackModal = React.memo(({ isOpen, onClose, onSubmit }) => {
      const [feedbackText, setFeedbackText] = React.useState('');
      const [isSubmitting, setIsSubmitting] = React.useState(false);
      const textareaRef = React.useRef(null);

      // Define handleClose with useCallback to prevent ESC effect from re-running unnecessarily
      const handleClose = React.useCallback(() => {
        setFeedbackText(''); // Clear feedback text
        setIsSubmitting(false); // Reset submitting state
        onClose(); // Call parent callback
      }, [onClose]);

      // Auto-focus textarea when modal opens
      // Note: No cleanup needed - focus is a one-time side effect
      React.useEffect(() => {
        if (isOpen && textareaRef.current) {
          textareaRef.current.focus();
        }
      }, [isOpen]);

      // ESC key handler - now safe with handleClose memoized
      React.useEffect(() => {
        const handleEsc = (event) => {
          if (event.key === 'Escape' && isOpen) {
            handleClose();
          }
        };

        document.addEventListener('keydown', handleEsc);
        return () => document.removeEventListener('keydown', handleEsc);
      }, [isOpen, handleClose]);

      const handleSubmit = () => {
        // Guard against double submission
        if (isSubmitting) return;

        // Validate feedback text
        if (!feedbackText.trim()) {
          return; // Button should be disabled, but defensive check
        }

        // Set submitting state
        setIsSubmitting(true);

        // Call parent submit handler
        onSubmit(feedbackText);

        // Note: Modal will close via parent's setIsFeedbackModalOpen(false)
        // State will be reset when modal closes via handleClose
      };

      const handleOverlayClick = (event) => {
        // Close only if overlay is clicked, not modal container
        if (event.target === event.currentTarget) {
          handleClose();
        }
      };

      if (!isOpen) return null;

      return (
        <div className="feedback-modal__overlay" onClick={handleOverlayClick}>
          <div
            className="feedback-modal"
            role="dialog"
            aria-labelledby="feedback-modal-title"
            aria-describedby="feedback-modal-description"
          >
            {/* Header */}
            <div className="feedback-modal__header">
              <h2 id="feedback-modal-title">Let's improve this result</h2>
            </div>

            {/* Body */}
            <div className="feedback-modal__body">
              <textarea
                ref={textareaRef}
                id="feedback-modal-description"
                className="feedback-modal__textarea"
                placeholder="What didn't you like about this result?"
                value={feedbackText}
                onChange={(e) => setFeedbackText(e.target.value)}
                rows={3}
                maxLength={500}
                aria-label="Feedback input"
                disabled={isSubmitting}
              />
              <p
                className={`feedback-modal__char-counter ${
                  feedbackText.length > 450 ? 'feedback-modal__char-counter--danger' :
                  feedbackText.length > 400 ? 'feedback-modal__char-counter--warning' : ''
                }`}
              >
                {feedbackText.length} / 500 characters
              </p>
            </div>

            {/* Footer */}
            <div className="feedback-modal__footer">
              <button
                className="feedback-modal__cancel-button"
                onClick={handleClose}
                disabled={isSubmitting}
              >
                Cancel
              </button>
              <button
                className="feedback-modal__submit-button"
                onClick={handleSubmit}
                disabled={!feedbackText.trim() || isSubmitting}
              >
                {isSubmitting ? 'Generating...' : 'Generate Improved Prompt'}
              </button>
            </div>
          </div>
        </div>
      );
    });

    // ComparisonModal - Layout component (Story 4.1)
    // Modal for side-by-side comparison of original vs improved prompts
    // Props: isOpen (boolean), comparisonData (object with originalPrompt, improvedPrompt), onClose (callback)
    // Story 4.2: Enhanced with HighlightedText component for improved prompt highlighting
    // Story 4.3: Enhanced with mapping badges and HighlightedSentences component
    const ComparisonModal = ({ isOpen, comparisonData, onClose }) => {
      const modalRef = React.useRef(null);
      const triggerElementRef = React.useRef(null);

      // Story 4.3: Parse mapping for badges (after guard clause, safe to access comparisonData)
      const { badges, sentenceMappings } = React.useMemo(() => {
        if (!comparisonData || !comparisonData.mapping) {
          return { badges: {}, sentenceMappings: [] };
        }
        return parseMapping(comparisonData.mapping, comparisonData.originalPrompt);
      }, [comparisonData]);

      // Story 4.3: State for interactive hover (optional)
      const [activeBadgeNumber, setActiveBadgeNumber] = React.useState(null);

      const handleBadgeHover = React.useCallback((badgeNumber) => {
        setActiveBadgeNumber(prevBadge => prevBadge === badgeNumber ? null : badgeNumber);
      }, []);

      // ESC key handler and keyboard focus trap
      React.useEffect(() => {
        const handleEscape = (e) => {
          if (e.key === 'Escape') {
            onClose();
          }
        };

        // Focus trap: Tab key cycles within modal only
        const handleTab = (e) => {
          if (e.key === 'Tab') {
            if (!modalRef.current) return;

            const focusableElements = modalRef.current.querySelectorAll(
              'button, [tabindex]:not([tabindex="-1"])'
            );

            if (focusableElements.length === 0) return;

            const firstElement = focusableElements[0];
            const lastElement = focusableElements[focusableElements.length - 1];

            if (e.shiftKey) {
              // Shift+Tab: Focus moving backwards
              if (document.activeElement === firstElement) {
                e.preventDefault();
                lastElement.focus();
              }
            } else {
              // Tab: Focus moving forwards
              if (document.activeElement === lastElement) {
                e.preventDefault();
                firstElement.focus();
              }
            }
          }
        };

        if (isOpen) {
          // Store trigger element for focus restoration
          triggerElementRef.current = document.activeElement;

          // Add event listeners
          document.addEventListener('keydown', handleEscape);
          document.addEventListener('keydown', handleTab);

          // Set initial focus to first focusable element
          if (modalRef.current) {
            const firstFocusable = modalRef.current.querySelector(
              'button, [tabindex]:not([tabindex="-1"])'
            );
            firstFocusable?.focus();
          }
        }

        return () => {
          // Cleanup: remove event listeners
          document.removeEventListener('keydown', handleEscape);
          document.removeEventListener('keydown', handleTab);

          // Return focus to trigger element when modal closes
          if (triggerElementRef.current) {
            triggerElementRef.current.focus();
          }
        };
      }, [isOpen, onClose]);

      // Guard clause - don't render if closed or no data
      if (!isOpen || !comparisonData) {
        return null;
      }

      // Story 4.2: Parse improved prompt for highlights (after guard clause, safe to access comparisonData)
      const highlights = parseImprovedPrompt(comparisonData.improvedPrompt);

      // Story 4.4: Extract explanations for tooltips (after guard clause, safe to access comparisonData)
      const explanations = comparisonData.explanations || [];

      // Overlay click handler
      const handleOverlayClick = (e) => {
        if (e.target.classList.contains('comparison-modal__overlay')) {
          onClose();
        }
      };

      return (
        <div className="comparison-modal__overlay" onClick={handleOverlayClick}>
          <div ref={modalRef} className="comparison-modal" role="dialog" aria-modal="true" aria-labelledby="modal-title">
            {/* Modal Header */}
            <div className="comparison-modal__header">
              <h2 id="modal-title" className="comparison-modal__title">
                See how your prompt improved
              </h2>
              <button
                className="comparison-modal__close-button"
                onClick={onClose}
                aria-label="Close modal"
              >
                ✕
              </button>
            </div>

            {/* Modal Body - Two Column Layout */}
            <div className="comparison-modal__body">
              {/* Left Column - Original Prompt (Story 4.3: WITH MAPPING HIGHLIGHTS) */}
              <div className="comparison-modal__column comparison-modal__column--original">
                <h3 className="comparison-modal__column-header">
                  Your Original Prompt
                </h3>
                <div className="comparison-modal__content">
                  {/* Story 4.3: Use HighlightedSentences with mapping badges */}
                  <HighlightedSentences
                    originalPrompt={comparisonData.originalPrompt}
                    sentenceMappings={sentenceMappings}
                  />
                </div>
              </div>

              {/* Right Column - Improved Prompt (Story 4.2: WITH HIGHLIGHTING, Story 4.3: WITH MAPPING BADGES) */}
              <div className="comparison-modal__column comparison-modal__column--improved">
                <h3 className="comparison-modal__column-header comparison-modal__column-header--improved">
                  Improved Version
                </h3>
                <div className="comparison-modal__content">
                  {/* Story 4.3: Use ImprovedPromptWithBadges instead of HighlightedText */}
                  {/* Story 4.4: Pass explanations prop for educational tooltips on section headers (Rules:, Task:, Examples:) */}
                  <ImprovedPromptWithBadges
                    text={comparisonData.improvedPrompt}
                    highlights={highlights}
                    badges={badges}
                    activeBadgeNumber={activeBadgeNumber}
                    onBadgeHover={handleBadgeHover}
                    explanations={explanations}
                  />
                </div>
              </div>
            </div>

            {/* Modal Footer - Use This Prompt Button */}
            <div className="comparison-modal__footer">
              <button
                className="comparison-modal__use-button"
                onClick={() => {
                  // Story 5.1 will implement "Use This Prompt" functionality
                  // For now, just close modal
                  onClose();
                }}
              >
                Use This Prompt
              </button>
            </div>
          </div>
        </div>
      );
    };

    // ============================================================
    // SECTION 5: CONTEXT PROVIDER
    // ============================================================

    // AppContext - Global application state
    const AppContext = React.createContext(null);

    // AC #2: AppProvider component with useState hooks and context value
    const AppProvider = ({ children }) => {
      // AC #1: Complete state structure
      // Chat state
      const [chatHistory, setChatHistory] = React.useState([]);
      const [isChatLoading, setIsChatLoading] = React.useState(false);
      const [chatError, setChatError] = React.useState(null);

      // Story 1.5: Validation state
      const [validationError, setValidationError] = React.useState(null);

      // Modal states
      const [isFeedbackModalOpen, setIsFeedbackModalOpen] = React.useState(false);
      const [isComparisonModalOpen, setIsComparisonModalOpen] = React.useState(false);
      const [comparisonData, setComparisonData] = React.useState(null);

      // Improvement state
      const [isGeneratingImprovement, setIsGeneratingImprovement] = React.useState(false);
      const [improvementError, setImprovementError] = React.useState(null);

      // Feedback context
      const [recentFeedback, setRecentFeedback] = React.useState(null);

      // Story 4.1: Close comparison modal handler
      const handleCloseComparisonModal = () => {
        setIsComparisonModalOpen(false);
        // Optionally clear comparisonData
        // setComparisonData(null);
      };

      // AC #3: Immutable state update helpers
      const addMessage = (message) => {
        setChatHistory(prev => [...prev, message]);
      };

      const clearChat = () => {
        setChatHistory([]);
        setChatError(null);
        setRecentFeedback(null);
        setComparisonData(null);
      };

      // Memoize context value to prevent unnecessary re-renders
      const value = React.useMemo(() => ({
        // State values
        chatHistory,
        isChatLoading,
        chatError,
        validationError,
        isFeedbackModalOpen,
        isComparisonModalOpen,
        comparisonData,
        isGeneratingImprovement,
        improvementError,
        recentFeedback,
        // State updaters
        setChatHistory,
        setIsChatLoading,
        setChatError,
        setValidationError,
        setIsFeedbackModalOpen,
        setIsComparisonModalOpen,
        setComparisonData,
        setIsGeneratingImprovement,
        setImprovementError,
        setRecentFeedback,
        // Helper functions
        addMessage,
        clearChat,
        handleCloseComparisonModal
      }), [
        chatHistory,
        isChatLoading,
        chatError,
        validationError,
        isFeedbackModalOpen,
        isComparisonModalOpen,
        comparisonData,
        isGeneratingImprovement,
        improvementError,
        recentFeedback
      ]);

      return (
        <AppContext.Provider value={value}>
          {children}
        </AppContext.Provider>
      );
    };

    // ============================================================
    // SECTION 6: MAIN APP COMPONENT
    // ============================================================
    const App = () => {
      const {
        isFeedbackModalOpen,
        setIsFeedbackModalOpen,
        isComparisonModalOpen,
        setIsComparisonModalOpen,
        comparisonData,
        setComparisonData,
        handleCloseComparisonModal,
        chatHistory,
        setRecentFeedback,
        setIsGeneratingImprovement,
        setImprovementError
      } = useAppContext();

      const handleFeedbackClose = () => {
        setIsFeedbackModalOpen(false);
      };

      const handleFeedbackSubmit = async (feedbackText) => {
        // Extract most recent messages from chat history
        // Find last user message
        const userMessages = chatHistory.filter(msg => msg.role === 'user');
        const lastUserMessage = userMessages[userMessages.length - 1];

        // Find last assistant message
        const assistantMessages = chatHistory.filter(msg => msg.role === 'assistant');
        const lastAssistantMessage = assistantMessages[assistantMessages.length - 1];

        // Edge case: No messages (shouldn't happen, but defensive)
        if (!lastUserMessage || !lastAssistantMessage) {
          console.error('No messages found in chat history');
          return;
        }

        // Create feedback object
        const feedback = {
          userPrompt: lastUserMessage.content,
          aiResponse: lastAssistantMessage.content,
          feedbackText: feedbackText,
          timestamp: Date.now()
        };

        // Store feedback in context
        setRecentFeedback(feedback);

        // Clear any previous improvement errors
        setImprovementError(null);

        // Trigger improvement generation state
        setIsGeneratingImprovement(true);

        // Close feedback modal
        setIsFeedbackModalOpen(false);

        try {
          // Call improvement API (Story 3.1 implementation)
          const { improvedPrompt, mapping, explanations } = await generateImprovement(
            feedback.userPrompt,
            feedback.feedbackText
          );

          // Store improvement data in context (for Epic 4 comparison modal)
          setComparisonData({
            originalPrompt: feedback.userPrompt,
            improvedPrompt: improvedPrompt,
            mapping: mapping,
            explanations: explanations
          });

          // Clear loading state
          setIsGeneratingImprovement(false);

          // Open comparison modal (Epic 4 will implement the modal)
          setIsComparisonModalOpen(true);

        } catch (error) {
          console.error('Improvement generation failed:', error);
          setIsGeneratingImprovement(false);

          // Show error in UI
          setImprovementError(error);
        }
      };

      return (
        <div className="app-container">
          <ChatInterface />

          {/* Feedback Modal */}
          <FeedbackModal
            isOpen={isFeedbackModalOpen}
            onClose={handleFeedbackClose}
            onSubmit={handleFeedbackSubmit}
          />

          {/* Story 4.1: Comparison Modal */}
          <ComparisonModal
            isOpen={isComparisonModalOpen}
            comparisonData={comparisonData}
            onClose={handleCloseComparisonModal}
          />
        </div>
      );
    };

    // ============================================================
    // SECTION 7: RENDER
    // ============================================================
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      <AppProvider>
        <ErrorBoundary>
          <App />
        </ErrorBoundary>
      </AppProvider>
    );
  </script>
</body>
</html>
